var Wt={},ka=(ba,on,wa)=>(Wt.__chunk_8072=(At,je,de)=>{"use strict";de.d(je,{Eh:()=>U,Il:()=>K,Kt:()=>F,yw:()=>C,ze:()=>q});var Oe=de(4270),xe=de(7798);let C="CPcrV6UeL8CcEvC7rCV6iyUDxbkT5bkJifbz5PUs6zfg",$="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",q={PRO_MONTHLY:24,PRO_YEARLY:240},U={PRO_MONTHLY:.11,PRO_YEARLY:1.1};function F(R){let ee=Date.now().toString(36),M=Math.random().toString(36).substring(2,6);return`WS-${R.substring(0,8)}-${ee}-${M}`.toUpperCase()}async function K({signature:R,expectedAmount:ee,expectedMemo:M,currency:le="SOL"}){try{if(!C)return{valid:!1,error:"Treasury wallet not configured"};let L=process.env.SOLANA_RPC_URL||"https://api.mainnet-beta.solana.com",j=new Oe.Ng(L,"confirmed"),Y=await j.getParsedTransaction(R,{maxSupportedTransactionVersion:0});if(!Y)return{valid:!1,error:"Transaction not found. It may still be confirming \u2014 try again in a moment."};if(Y.meta?.err)return{valid:!1,error:"Transaction failed on-chain"};let Ee=Y.blockTime;if(Ee&&Math.floor(Date.now()/1e3)-Ee>3600)return{valid:!1,error:"Transaction too old (>1 hour). Please make a new payment."};let H=new Oe.J3(C),Ce=!1,Ge=0;if(le==="SOL"){for(let w of Y.transaction.message.instructions)if("parsed"in w&&w.parsed?.type==="transfer"){let v=w.parsed.info;if(v.destination===H.toString()){Ge=v.lamports/Oe.Sr,Ce=!0;break}}}else{let w=await(0,xe.Ob)(new Oe.J3($),H);for(let v of Y.transaction.message.instructions){if("parsed"in v&&v.parsed?.type==="transferChecked"){let z=v.parsed.info;if(z.mint===$&&z.destination===w.toString()){Ge=parseFloat(z.tokenAmount.uiAmount),Ce=!0;break}}if("parsed"in v&&v.parsed?.type==="transfer"){let z=v.parsed.info;if(z.destination===w.toString()){Ge=parseFloat(z.amount)/1e6,Ce=!0;break}}}}if(!Ce)return{valid:!1,error:"No payment to treasury wallet found in this transaction"};if(Ge<.99*ee)return{valid:!1,error:`Insufficient amount: expected $${ee}, received $${Ge.toFixed(2)}`};let Le=Y.transaction.message.instructions.find(w=>"programId"in w&&w.programId.toString()==="MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),re=!1;if(Le&&"parsed"in Le){let w=Le.parsed;typeof w=="string"&&w.includes(M)&&(re=!0)}return re||console.warn(`[Payment] Tx ${R} accepted \u2014 amount & destination verified, memo missing/mismatched`),{valid:!0}}catch(L){return console.error("Transaction verification error:",L),{valid:!1,error:"Verification failed \u2014 please try again"}}}},Wt.__chunk_9921=(At,je,de)=>{"use strict";let Oe=de(2972).v4;At.exports=function(xe,C,$,q){if(typeof xe!="string")throw TypeError(xe+" must be a string");let U=typeof(q=q||{}).version=="number"?q.version:2;if(U!==1&&U!==2)throw TypeError(U+" must be 1 or 2");let F={method:xe};if(U===2&&(F.jsonrpc="2.0"),C){if(typeof C!="object"&&!Array.isArray(C))throw TypeError(C+" must be an object, array or omitted");F.params=C}return $===void 0?F.id=(typeof q.generator=="function"?q.generator:function(){return Oe()})(F,q):U===2&&$===null?q.notificationIdNull&&(F.id=null):F.id=$,F}},Wt.__chunk_7989=(At,je,de)=>{"use strict";var Oe=de(4221).Buffer;At.exports=function(xe){if(xe.length>=255)throw TypeError("Alphabet too long");for(var C=new Uint8Array(256),$=0;$<C.length;$++)C[$]=255;for(var q=0;q<xe.length;q++){var U=xe.charAt(q),F=U.charCodeAt(0);if(C[F]!==255)throw TypeError(U+" is ambiguous");C[F]=q}var K=xe.length,R=xe.charAt(0),ee=Math.log(K)/Math.log(256),M=Math.log(256)/Math.log(K);function le(L){if(typeof L!="string")throw TypeError("Expected String");if(L.length===0)return Oe.alloc(0);for(var j=0,Y=0,Ee=0;L[j]===R;)Y++,j++;for(var H=(L.length-j)*ee+1>>>0,Ce=new Uint8Array(H);j<L.length;){var Ge=L.charCodeAt(j);if(Ge>255)return;var Le=C[Ge];if(Le===255)return;for(var re=0,w=H-1;(Le!==0||re<Ee)&&w!==-1;w--,re++)Le+=K*Ce[w]>>>0,Ce[w]=Le%256>>>0,Le=Le/256>>>0;if(Le!==0)throw Error("Non-zero carry");Ee=re,j++}for(var v=H-Ee;v!==H&&Ce[v]===0;)v++;var z=Oe.allocUnsafe(Y+(H-v));z.fill(0,0,Y);for(var ge=Y;v!==H;)z[ge++]=Ce[v++];return z}return{encode:function(L){if((Array.isArray(L)||L instanceof Uint8Array)&&(L=Oe.from(L)),!Oe.isBuffer(L))throw TypeError("Expected Buffer");if(L.length===0)return"";for(var j=0,Y=0,Ee=0,H=L.length;Ee!==H&&L[Ee]===0;)Ee++,j++;for(var Ce=(H-Ee)*M+1>>>0,Ge=new Uint8Array(Ce);Ee!==H;){for(var Le=L[Ee],re=0,w=Ce-1;(Le!==0||re<Y)&&w!==-1;w--,re++)Le+=256*Ge[w]>>>0,Ge[w]=Le%K>>>0,Le=Le/K>>>0;if(Le!==0)throw Error("Non-zero carry");Y=re,Ee++}for(var v=Ce-Y;v!==Ce&&Ge[v]===0;)v++;for(var z=R.repeat(j);v<Ce;++v)z+=xe.charAt(Ge[v]);return z},decodeUnsafe:le,decode:function(L){var j=le(L);if(j)return j;throw Error("Non-base"+K+" character")}}}},Wt.__chunk_7901=(At,je,de)=>{At.exports=de(82)("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},Wt.__chunk_7798=(At,je,de)=>{"use strict";de.d(je,{Ob:()=>xt});var Oe=de(3537),xe=de(6264);let C=ie=>({decode:ie.decode.bind(ie),encode:ie.encode.bind(ie)});var $=de(5356).Buffer;let q=ie=>ae=>{let Fe=(0,Oe.av)(ie,ae),{encode:lt,decode:Ye}=C(Fe);return Fe.decode=(ot,dt)=>{let Et=Ye(ot,dt);return(0,xe.k5)($.from(Et))},Fe.encode=(ot,dt,Et)=>lt((0,xe.Bq)(ot,ie),dt,Et),Fe},U=ie=>ae=>{let Fe=(0,Oe.av)(ie,ae),{encode:lt,decode:Ye}=C(Fe);return Fe.decode=(ot,dt)=>{let Et=Ye(ot,dt);return(0,xe.cI)($.from(Et))},Fe.encode=(ot,dt,Et)=>lt((0,xe.zy)(ot,ie),dt,Et),Fe},F=q(8);U(8),q(16),U(16),q(24),U(24),q(32),U(32);var K=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,R=Math.ceil,ee=Math.floor,M="[BigNumber Error] ",le=M+"Number primitive has more than 15 significant digits: ",L=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13];function j(ie){var ae=0|ie;return ie>0||ie===ae?ae:ae-1}function Y(ie){for(var ae,Fe,lt=1,Ye=ie.length,ot=ie[0]+"";lt<Ye;){for(Fe=14-(ae=ie[lt++]+"").length;Fe--;ae="0"+ae);ot+=ae}for(Ye=ot.length;ot.charCodeAt(--Ye)===48;);return ot.slice(0,Ye+1||1)}function Ee(ie,ae){var Fe,lt,Ye=ie.c,ot=ae.c,dt=ie.s,Et=ae.s,wt=ie.e,Ut=ae.e;if(!dt||!Et)return null;if(Fe=Ye&&!Ye[0],lt=ot&&!ot[0],Fe||lt)return Fe?lt?0:-Et:dt;if(dt!=Et)return dt;if(Fe=dt<0,lt=wt==Ut,!Ye||!ot)return lt?0:!Ye^Fe?1:-1;if(!lt)return wt>Ut^Fe?1:-1;for(dt=0,Et=(wt=Ye.length)<(Ut=ot.length)?wt:Ut;dt<Et;dt++)if(Ye[dt]!=ot[dt])return Ye[dt]>ot[dt]^Fe?1:-1;return wt==Ut?0:wt>Ut^Fe?1:-1}function H(ie,ae,Fe,lt){if(ie<ae||ie>Fe||ie!==ee(ie))throw Error(M+(lt||"Argument")+(typeof ie=="number"?ie<ae||ie>Fe?" out of range: ":" not an integer: ":" not a primitive number: ")+String(ie))}function Ce(ie){var ae=ie.c.length-1;return j(ie.e/14)==ae&&ie.c[ae]%2!=0}function Ge(ie,ae){return(ie.length>1?ie.charAt(0)+"."+ie.slice(1):ie)+(ae<0?"e":"e+")+ae}function Le(ie,ae,Fe){var lt,Ye;if(ae<0){for(Ye=Fe+".";++ae;Ye+=Fe);ie=Ye+ie}else if(lt=ie.length,++ae>lt){for(Ye=Fe,ae-=lt;--ae;Ye+=Fe);ie+=Ye}else ae<lt&&(ie=ie.slice(0,ae)+"."+ie.slice(ae));return ie}new(function ie(ae){var Fe,lt,Ye,ot,dt,Et,wt,Ut,nr,we=V.prototype={constructor:V,toString:null,valueOf:null},ir=new V(1),Kt=20,Pt=4,sr=-7,fr=21,or=-1e7,Ft=1e7,Rt=!1,vr=1,Qt=0,Fr={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:"\xA0",suffix:""},ar="0123456789abcdefghijklmnopqrstuvwxyz",Gt=!0;function V(c,d){var y,B,x,A,k,E,O,_,T=this;if(!(T instanceof V))return new V(c,d);if(d==null){if(c&&c._isBigNumber===!0){T.s=c.s,!c.c||c.e>Ft?T.c=T.e=null:c.e<or?T.c=[T.e=0]:(T.e=c.e,T.c=c.c.slice());return}if((E=typeof c=="number")&&0*c==0){if(T.s=1/c<0?(c=-c,-1):1,c===~~c){for(A=0,k=c;k>=10;k/=10,A++);A>Ft?T.c=T.e=null:(T.e=A,T.c=[c]);return}_=String(c)}else{if(!K.test(_=String(c)))return nr(T,_,E);T.s=_.charCodeAt(0)==45?(_=_.slice(1),-1):1}(A=_.indexOf("."))>-1&&(_=_.replace(".","")),(k=_.search(/e/i))>0?(A<0&&(A=k),A+=+_.slice(k+1),_=_.substring(0,k)):A<0&&(A=_.length)}else{if(H(d,2,ar.length,"Base"),d==10&&Gt)return Lt(T=new V(c),Kt+T.e+1,Pt);if(_=String(c),E=typeof c=="number"){if(0*c!=0)return nr(T,_,E,d);if(T.s=1/c<0?(_=_.slice(1),-1):1,V.DEBUG&&_.replace(/^0\.0*|\./,"").length>15)throw Error(le+c)}else T.s=_.charCodeAt(0)===45?(_=_.slice(1),-1):1;for(y=ar.slice(0,d),A=k=0,O=_.length;k<O;k++)if(0>y.indexOf(B=_.charAt(k))){if(B=="."){if(k>A){A=O;continue}}else if(!x&&(_==_.toUpperCase()&&(_=_.toLowerCase())||_==_.toLowerCase()&&(_=_.toUpperCase()))){x=!0,k=-1,A=0;continue}return nr(T,String(c),E,d)}E=!1,(A=(_=Ut(_,d,10,T.s)).indexOf("."))>-1?_=_.replace(".",""):A=_.length}for(k=0;_.charCodeAt(k)===48;k++);for(O=_.length;_.charCodeAt(--O)===48;);if(_=_.slice(k,++O)){if(O-=k,E&&V.DEBUG&&O>15&&(c>9007199254740991||c!==ee(c)))throw Error(le+T.s*c);if((A=A-k-1)>Ft)T.c=T.e=null;else if(A<or)T.c=[T.e=0];else{if(T.e=A,T.c=[],k=(A+1)%14,A<0&&(k+=14),k<O){for(k&&T.c.push(+_.slice(0,k)),O-=14;k<O;)T.c.push(+_.slice(k,k+=14));k=14-(_=_.slice(k)).length}else k-=O;for(;k--;_+="0");T.c.push(+_)}}else T.c=[T.e=0]}function jr(c,d,y,B){var x,A,k,E,O;if(y==null?y=Pt:H(y,0,8),!c.c)return c.toString();if(x=c.c[0],k=c.e,d==null)O=Y(c.c),O=B==1||B==2&&(k<=sr||k>=fr)?Ge(O,k):Le(O,k,"0");else if(A=(c=Lt(new V(c),d,y)).e,E=(O=Y(c.c)).length,B==1||B==2&&(d<=A||A<=sr)){for(;E<d;O+="0",E++);O=Ge(O,A)}else if(d-=k+(B===2&&A>k),O=Le(O,A,"0"),A+1>E){if(--d>0)for(O+=".";d--;O+="0");}else if((d+=A-E)>0)for(A+1==E&&(O+=".");d--;O+="0");return c.s<0&&x?"-"+O:O}function Tr(c,d){for(var y,B,x=1,A=new V(c[0]);x<c.length;x++)(B=new V(c[x])).s&&(y=Ee(A,B))!==d&&(y!==0||A.s!==d)||(A=B);return A}function Mr(c,d,y){for(var B=1,x=d.length;!d[--x];d.pop());for(x=d[0];x>=10;x/=10,B++);return(y=B+14*y-1)>Ft?c.c=c.e=null:y<or?c.c=[c.e=0]:(c.e=y,c.c=d),c}function Lt(c,d,y,B){var x,A,k,E,O,_,T,X=c.c;if(X){e:{for(x=1,E=X[0];E>=10;E/=10,x++);if((A=d-x)<0)A+=14,k=d,T=ee((O=X[_=0])/L[x-k-1]%10);else if((_=R((A+1)/14))>=X.length)if(B){for(;X.length<=_;X.push(0));O=T=0,x=1,A%=14,k=A-14+1}else break e;else{for(x=1,O=E=X[_];E>=10;E/=10,x++);A%=14,T=(k=A-14+x)<0?0:ee(O/L[x-k-1]%10)}if(B=B||d<0||X[_+1]!=null||(k<0?O:O%L[x-k-1]),B=y<4?(T||B)&&(y==0||y==(c.s<0?3:2)):T>5||T==5&&(y==4||B||y==6&&(A>0?k>0?O/L[x-k]:0:X[_-1])%10&1||y==(c.s<0?8:7)),d<1||!X[0])return X.length=0,B?(d-=c.e+1,X[0]=L[(14-d%14)%14],c.e=-d||0):X[0]=c.e=0,c;if(A==0?(X.length=_,E=1,_--):(X.length=_+1,E=L[14-A],X[_]=k>0?ee(O/L[x-k]%L[k])*E:0),B)for(;;)if(_==0){for(A=1,k=X[0];k>=10;k/=10,A++);for(k=X[0]+=E,E=1;k>=10;k/=10,E++);A!=E&&(c.e++,X[0]==1e14&&(X[0]=1));break}else{if(X[_]+=E,X[_]!=1e14)break;X[_--]=0,E=1}for(A=X.length;X[--A]===0;X.pop());}c.e>Ft?c.c=c.e=null:c.e<or&&(c.c=[c.e=0])}return c}function jt(c){var d,y=c.e;return y===null?c.toString():(d=Y(c.c),d=y<=sr||y>=fr?Ge(d,y):Le(d,y,"0"),c.s<0?"-"+d:d)}return V.clone=ie,V.ROUND_UP=0,V.ROUND_DOWN=1,V.ROUND_CEIL=2,V.ROUND_FLOOR=3,V.ROUND_HALF_UP=4,V.ROUND_HALF_DOWN=5,V.ROUND_HALF_EVEN=6,V.ROUND_HALF_CEIL=7,V.ROUND_HALF_FLOOR=8,V.EUCLID=9,V.config=V.set=function(c){var d,y;if(c!=null)if(typeof c=="object"){if(c.hasOwnProperty(d="DECIMAL_PLACES")&&(H(y=c[d],0,1e9,d),Kt=y),c.hasOwnProperty(d="ROUNDING_MODE")&&(H(y=c[d],0,8,d),Pt=y),c.hasOwnProperty(d="EXPONENTIAL_AT")&&((y=c[d])&&y.pop?(H(y[0],-1e9,0,d),H(y[1],0,1e9,d),sr=y[0],fr=y[1]):(H(y,-1e9,1e9,d),sr=-(fr=y<0?-y:y))),c.hasOwnProperty(d="RANGE"))if((y=c[d])&&y.pop)H(y[0],-1e9,-1,d),H(y[1],1,1e9,d),or=y[0],Ft=y[1];else if(H(y,-1e9,1e9,d),y)or=-(Ft=y<0?-y:y);else throw Error(M+d+" cannot be zero: "+y);if(c.hasOwnProperty(d="CRYPTO"))if(!!(y=c[d])===y)if(y)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))Rt=y;else throw Rt=!y,Error(M+"crypto unavailable");else Rt=y;else throw Error(M+d+" not true or false: "+y);if(c.hasOwnProperty(d="MODULO_MODE")&&(H(y=c[d],0,9,d),vr=y),c.hasOwnProperty(d="POW_PRECISION")&&(H(y=c[d],0,1e9,d),Qt=y),c.hasOwnProperty(d="FORMAT"))if(typeof(y=c[d])=="object")Fr=y;else throw Error(M+d+" not an object: "+y);if(c.hasOwnProperty(d="ALPHABET")){if(typeof(y=c[d])!="string"||/^.?$|[+\-.\s]|(.).*\1/.test(y))throw Error(M+d+" invalid: "+y);Gt=y.slice(0,10)=="0123456789",ar=y}}else throw Error(M+"Object expected: "+c);return{DECIMAL_PLACES:Kt,ROUNDING_MODE:Pt,EXPONENTIAL_AT:[sr,fr],RANGE:[or,Ft],CRYPTO:Rt,MODULO_MODE:vr,POW_PRECISION:Qt,FORMAT:Fr,ALPHABET:ar}},V.isBigNumber=function(c){if(!c||c._isBigNumber!==!0)return!1;if(!V.DEBUG)return!0;var d,y,B=c.c,x=c.e,A=c.s;e:if({}.toString.call(B)=="[object Array]"){if((A===1||A===-1)&&x>=-1e9&&x<=1e9&&x===ee(x)){if(B[0]===0){if(x===0&&B.length===1)return!0;break e}if((d=(x+1)%14)<1&&(d+=14),String(B[0]).length==d){for(d=0;d<B.length;d++)if((y=B[d])<0||y>=1e14||y!==ee(y))break e;if(y!==0)return!0}}}else if(B===null&&x===null&&(A===null||A===1||A===-1))return!0;throw Error(M+"Invalid BigNumber: "+c)},V.maximum=V.max=function(){return Tr(arguments,-1)},V.minimum=V.min=function(){return Tr(arguments,1)},Fe=9007199254740992*Math.random()&2097151?function(){return ee(9007199254740992*Math.random())}:function(){return(1073741824*Math.random()|0)*8388608+(8388608*Math.random()|0)},V.random=function(c){var d,y,B,x,A,k=0,E=[],O=new V(ir);if(c==null?c=Kt:H(c,0,1e9),x=R(c/14),Rt)if(crypto.getRandomValues){for(d=crypto.getRandomValues(new Uint32Array(x*=2));k<x;)(A=131072*d[k]+(d[k+1]>>>11))>=9e15?(y=crypto.getRandomValues(new Uint32Array(2)),d[k]=y[0],d[k+1]=y[1]):(E.push(A%1e14),k+=2);k=x/2}else if(crypto.randomBytes){for(d=crypto.randomBytes(x*=7);k<x;)(A=(31&d[k])*281474976710656+1099511627776*d[k+1]+4294967296*d[k+2]+16777216*d[k+3]+(d[k+4]<<16)+(d[k+5]<<8)+d[k+6])>=9e15?crypto.randomBytes(7).copy(d,k):(E.push(A%1e14),k+=7);k=x/7}else throw Rt=!1,Error(M+"crypto unavailable");if(!Rt)for(;k<x;)(A=Fe())<9e15&&(E[k++]=A%1e14);for(x=E[--k],c%=14,x&&c&&(A=L[14-c],E[k]=ee(x/A)*A);E[k]===0;E.pop(),k--);if(k<0)E=[B=0];else{for(B=-1;E[0]===0;E.splice(0,1),B-=14);for(k=1,A=E[0];A>=10;A/=10,k++);k<14&&(B-=14-k)}return O.e=B,O.c=E,O},V.sum=function(){for(var c=1,d=arguments,y=new V(d[0]);c<d.length;)y=y.plus(d[c++]);return y},Ut=function(){var c="0123456789";function d(y,B,x,A){for(var k,E,O=[0],_=0,T=y.length;_<T;){for(E=O.length;E--;O[E]*=B);for(O[0]+=A.indexOf(y.charAt(_++)),k=0;k<O.length;k++)O[k]>x-1&&(O[k+1]==null&&(O[k+1]=0),O[k+1]+=O[k]/x|0,O[k]%=x)}return O.reverse()}return function(y,B,x,A,k){var E,O,_,T,X,He,Ke,mt,ct=y.indexOf("."),Je=Kt,Me=Pt;for(ct>=0&&(T=Qt,Qt=0,y=y.replace(".",""),He=(mt=new V(B)).pow(y.length-ct),Qt=T,mt.c=d(Le(Y(He.c),He.e,"0"),10,x,c),mt.e=mt.c.length),_=T=(Ke=d(y,B,x,k?(E=ar,c):(E=c,ar))).length;Ke[--T]==0;Ke.pop());if(!Ke[0])return E.charAt(0);if(ct<0?--_:(He.c=Ke,He.e=_,He.s=A,Ke=(He=wt(He,mt,Je,Me,x)).c,X=He.r,_=He.e),ct=Ke[O=_+Je+1],T=x/2,X=X||O<0||Ke[O+1]!=null,X=Me<4?(ct!=null||X)&&(Me==0||Me==(He.s<0?3:2)):ct>T||ct==T&&(Me==4||X||Me==6&&1&Ke[O-1]||Me==(He.s<0?8:7)),O<1||!Ke[0])y=X?Le(E.charAt(1),-Je,E.charAt(0)):E.charAt(0);else{if(Ke.length=O,X)for(--x;++Ke[--O]>x;)Ke[O]=0,O||(++_,Ke=[1].concat(Ke));for(T=Ke.length;!Ke[--T];);for(ct=0,y="";ct<=T;y+=E.charAt(Ke[ct++]));y=Le(y,_,E.charAt(0))}return y}}(),wt=function(){function c(B,x,A){var k,E,O,_,T=0,X=B.length,He=x%1e7,Ke=x/1e7|0;for(B=B.slice();X--;)k=Ke*(O=B[X]%1e7)+(_=B[X]/1e7|0)*He,T=((E=He*O+k%1e7*1e7+T)/A|0)+(k/1e7|0)+Ke*_,B[X]=E%A;return T&&(B=[T].concat(B)),B}function d(B,x,A,k){var E,O;if(A!=k)O=A>k?1:-1;else for(E=O=0;E<A;E++)if(B[E]!=x[E]){O=B[E]>x[E]?1:-1;break}return O}function y(B,x,A,k){for(var E=0;A--;)B[A]-=E,E=+(B[A]<x[A]),B[A]=E*k+B[A]-x[A];for(;!B[0]&&B.length>1;B.splice(0,1));}return function(B,x,A,k,E){var O,_,T,X,He,Ke,mt,ct,Je,Me,St,Sr,xr,Cr,Vr,Mt,Rr,qt=B.s==x.s?1:-1,it=B.c,Ve=x.c;if(!it||!it[0]||!Ve||!Ve[0])return new V(!B.s||!x.s||(it?Ve&&it[0]==Ve[0]:!Ve)?NaN:it&&it[0]==0||!Ve?0*qt:qt/0);for(Je=(ct=new V(qt)).c=[],qt=A+(_=B.e-x.e)+1,E||(E=1e14,_=j(B.e/14)-j(x.e/14),qt=qt/14|0),T=0;Ve[T]==(it[T]||0);T++);if(Ve[T]>(it[T]||0)&&_--,qt<0)Je.push(1),X=!0;else{for(Cr=it.length,Mt=Ve.length,T=0,qt+=2,(He=ee(E/(Ve[0]+1)))>1&&(Ve=c(Ve,He,E),it=c(it,He,E),Mt=Ve.length,Cr=it.length),xr=Mt,St=(Me=it.slice(0,Mt)).length;St<Mt;Me[St++]=0);Rr=[0].concat(Rr=Ve.slice()),Vr=Ve[0],Ve[1]>=E/2&&Vr++;do{if(He=0,(O=d(Ve,Me,Mt,St))<0){if(Sr=Me[0],Mt!=St&&(Sr=Sr*E+(Me[1]||0)),(He=ee(Sr/Vr))>1)for(He>=E&&(He=E-1),mt=(Ke=c(Ve,He,E)).length,St=Me.length;d(Ke,Me,mt,St)==1;)He--,y(Ke,Mt<mt?Rr:Ve,mt,E),mt=Ke.length,O=1;else He==0&&(O=He=1),mt=(Ke=Ve.slice()).length;if(mt<St&&(Ke=[0].concat(Ke)),y(Me,Ke,St,E),St=Me.length,O==-1)for(;1>d(Ve,Me,Mt,St);)He++,y(Me,Mt<St?Rr:Ve,St,E),St=Me.length}else O===0&&(He++,Me=[0]);Je[T++]=He,Me[0]?Me[St++]=it[xr]||0:(Me=[it[xr]],St=1)}while((xr++<Cr||Me[0]!=null)&&qt--);X=Me[0]!=null,Je[0]||Je.splice(0,1)}if(E==1e14){for(T=1,qt=Je[0];qt>=10;qt/=10,T++);Lt(ct,A+(ct.e=T+14*_-1)+1,k,X)}else ct.e=_,ct.r=+X;return ct}}(),lt=/^(-?)0([xbo])(?=\w[\w.]*$)/i,Ye=/^([^.]+)\.$/,ot=/^\.([^.]+)$/,dt=/^-?(Infinity|NaN)$/,Et=/^\s*\+(?=[\w.])|^\s+|\s+$/g,nr=function(c,d,y,B){var x,A=y?d:d.replace(Et,"");if(dt.test(A))c.s=isNaN(A)?null:A<0?-1:1;else{if(!y&&(A=A.replace(lt,function(k,E,O){return x=(O=O.toLowerCase())=="x"?16:O=="b"?2:8,B&&B!=x?k:E}),B&&(x=B,A=A.replace(Ye,"$1").replace(ot,"0.$1")),d!=A))return new V(A,x);if(V.DEBUG)throw Error(M+"Not a"+(B?" base "+B:"")+" number: "+d);c.s=null}c.c=c.e=null},we.absoluteValue=we.abs=function(){var c=new V(this);return c.s<0&&(c.s=1),c},we.comparedTo=function(c,d){return Ee(this,new V(c,d))},we.decimalPlaces=we.dp=function(c,d){var y,B,x;if(c!=null)return H(c,0,1e9),d==null?d=Pt:H(d,0,8),Lt(new V(this),c+this.e+1,d);if(!(y=this.c))return null;if(B=((x=y.length-1)-j(this.e/14))*14,x=y[x])for(;x%10==0;x/=10,B--);return B<0&&(B=0),B},we.dividedBy=we.div=function(c,d){return wt(this,new V(c,d),Kt,Pt)},we.dividedToIntegerBy=we.idiv=function(c,d){return wt(this,new V(c,d),0,1)},we.exponentiatedBy=we.pow=function(c,d){var y,B,x,A,k,E,O,_,T,X=this;if((c=new V(c)).c&&!c.isInteger())throw Error(M+"Exponent not an integer: "+jt(c));if(d!=null&&(d=new V(d)),E=c.e>14,!X.c||!X.c[0]||X.c[0]==1&&!X.e&&X.c.length==1||!c.c||!c.c[0])return T=new V(Math.pow(+jt(X),E?c.s*(2-Ce(c)):+jt(c))),d?T.mod(d):T;if(O=c.s<0,d){if(d.c?!d.c[0]:!d.s)return new V(NaN);(B=!O&&X.isInteger()&&d.isInteger())&&(X=X.mod(d))}else{if(c.e>9&&(X.e>0||X.e<-1||(X.e==0?X.c[0]>1||E&&X.c[1]>=24e7:X.c[0]<8e13||E&&X.c[0]<=9999975e7)))return A=X.s<0&&Ce(c)?-0:0,X.e>-1&&(A=1/A),new V(O?1/A:A);Qt&&(A=R(Qt/14+2))}for(E?(y=new V(.5),O&&(c.s=1),_=Ce(c)):_=(x=Math.abs(+jt(c)))%2,T=new V(ir);;){if(_){if(!(T=T.times(X)).c)break;A?T.c.length>A&&(T.c.length=A):B&&(T=T.mod(d))}if(x){if((x=ee(x/2))===0)break;_=x%2}else if(Lt(c=c.times(y),c.e+1,1),c.e>14)_=Ce(c);else{if((x=+jt(c))==0)break;_=x%2}X=X.times(X),A?X.c&&X.c.length>A&&(X.c.length=A):B&&(X=X.mod(d))}return B?T:(O&&(T=ir.div(T)),d?T.mod(d):A?Lt(T,Qt,Pt,k):T)},we.integerValue=function(c){var d=new V(this);return c==null?c=Pt:H(c,0,8),Lt(d,d.e+1,c)},we.isEqualTo=we.eq=function(c,d){return Ee(this,new V(c,d))===0},we.isFinite=function(){return!!this.c},we.isGreaterThan=we.gt=function(c,d){return Ee(this,new V(c,d))>0},we.isGreaterThanOrEqualTo=we.gte=function(c,d){return(d=Ee(this,new V(c,d)))===1||d===0},we.isInteger=function(){return!!this.c&&j(this.e/14)>this.c.length-2},we.isLessThan=we.lt=function(c,d){return 0>Ee(this,new V(c,d))},we.isLessThanOrEqualTo=we.lte=function(c,d){return(d=Ee(this,new V(c,d)))===-1||d===0},we.isNaN=function(){return!this.s},we.isNegative=function(){return this.s<0},we.isPositive=function(){return this.s>0},we.isZero=function(){return!!this.c&&this.c[0]==0},we.minus=function(c,d){var y,B,x,A,k=this.s;if(d=(c=new V(c,d)).s,!k||!d)return new V(NaN);if(k!=d)return c.s=-d,this.plus(c);var E=this.e/14,O=c.e/14,_=this.c,T=c.c;if(!E||!O){if(!_||!T)return _?(c.s=-d,c):new V(T?this:NaN);if(!_[0]||!T[0])return T[0]?(c.s=-d,c):new V(_[0]?this:Pt==3?-0:0)}if(E=j(E),O=j(O),_=_.slice(),k=E-O){for((A=k<0)?(k=-k,x=_):(O=E,x=T),x.reverse(),d=k;d--;x.push(0));x.reverse()}else for(B=(A=(k=_.length)<(d=T.length))?k:d,k=d=0;d<B;d++)if(_[d]!=T[d]){A=_[d]<T[d];break}if(A&&(x=_,_=T,T=x,c.s=-c.s),(d=(B=T.length)-(y=_.length))>0)for(;d--;_[y++]=0);for(d=99999999999999;B>k;){if(_[--B]<T[B]){for(y=B;y&&!_[--y];_[y]=d);--_[y],_[B]+=1e14}_[B]-=T[B]}for(;_[0]==0;_.splice(0,1),--O);return _[0]?Mr(c,_,O):(c.s=Pt==3?-1:1,c.c=[c.e=0],c)},we.modulo=we.mod=function(c,d){var y,B;return c=new V(c,d),this.c&&c.s&&(!c.c||c.c[0])?c.c&&(!this.c||this.c[0])?(vr==9?(B=c.s,c.s=1,y=wt(this,c,0,3),c.s=B,y.s*=B):y=wt(this,c,0,vr),(c=this.minus(y.times(c))).c[0]||vr!=1||(c.s=this.s),c):new V(this):new V(NaN)},we.multipliedBy=we.times=function(c,d){var y,B,x,A,k,E,O,_,T,X,He,Ke,mt,ct=this.c,Je=(c=new V(c,d)).c;if(!ct||!Je||!ct[0]||!Je[0])return this.s&&c.s&&(!ct||ct[0]||Je)&&(!Je||Je[0]||ct)?(c.s*=this.s,ct&&Je?(c.c=[0],c.e=0):c.c=c.e=null):c.c=c.e=c.s=null,c;for(B=j(this.e/14)+j(c.e/14),c.s*=this.s,(O=ct.length)<(X=Je.length)&&(mt=ct,ct=Je,Je=mt,x=O,O=X,X=x),x=O+X,mt=[];x--;mt.push(0));for(x=X;--x>=0;){for(y=0,He=Je[x]%1e7,Ke=Je[x]/1e7|0,A=x+(k=O);A>x;)E=Ke*(_=ct[--k]%1e7)+(T=ct[k]/1e7|0)*He,y=((_=He*_+E%1e7*1e7+mt[A]+y)/1e14|0)+(E/1e7|0)+Ke*T,mt[A--]=_%1e14;mt[A]=y}return y?++B:mt.splice(0,1),Mr(c,mt,B)},we.negated=function(){var c=new V(this);return c.s=-c.s||null,c},we.plus=function(c,d){var y,B=this.s;if(d=(c=new V(c,d)).s,!B||!d)return new V(NaN);if(B!=d)return c.s=-d,this.minus(c);var x=this.e/14,A=c.e/14,k=this.c,E=c.c;if(!x||!A){if(!k||!E)return new V(B/0);if(!k[0]||!E[0])return E[0]?c:new V(k[0]?this:0*B)}if(x=j(x),A=j(A),k=k.slice(),B=x-A){for(B>0?(A=x,y=E):(B=-B,y=k),y.reverse();B--;y.push(0));y.reverse()}for((B=k.length)-(d=E.length)<0&&(y=E,E=k,k=y,d=B),B=0;d;)B=(k[--d]=k[d]+E[d]+B)/1e14|0,k[d]=k[d]===1e14?0:k[d]%1e14;return B&&(k=[B].concat(k),++A),Mr(c,k,A)},we.precision=we.sd=function(c,d){var y,B,x;if(c!=null&&!!c!==c)return H(c,1,1e9),d==null?d=Pt:H(d,0,8),Lt(new V(this),c,d);if(!(y=this.c))return null;if(B=14*(x=y.length-1)+1,x=y[x]){for(;x%10==0;x/=10,B--);for(x=y[0];x>=10;x/=10,B++);}return c&&this.e+1>B&&(B=this.e+1),B},we.shiftedBy=function(c){return H(c,-9007199254740991,9007199254740991),this.times("1e"+c)},we.squareRoot=we.sqrt=function(){var c,d,y,B,x,A=this.c,k=this.s,E=this.e,O=Kt+4,_=new V("0.5");if(k!==1||!A||!A[0])return new V(!k||k<0&&(!A||A[0])?NaN:A?this:1/0);if((k=Math.sqrt(+jt(this)))==0||k==1/0?(((d=Y(A)).length+E)%2==0&&(d+="0"),k=Math.sqrt(+d),E=j((E+1)/2)-(E<0||E%2),y=new V(d=k==1/0?"5e"+E:(d=k.toExponential()).slice(0,d.indexOf("e")+1)+E)):y=new V(k+""),y.c[0]){for((k=(E=y.e)+O)<3&&(k=0);;)if(x=y,y=_.times(x.plus(wt(this,x,O,1))),Y(x.c).slice(0,k)===(d=Y(y.c)).slice(0,k)){if(y.e<E&&--k,(d=d.slice(k-3,k+1))!="9999"&&(B||d!="4999")){+d&&(+d.slice(1)||d.charAt(0)!="5")||(Lt(y,y.e+Kt+2,1),c=!y.times(y).eq(this));break}if(!B&&(Lt(x,x.e+Kt+2,0),x.times(x).eq(this))){y=x;break}O+=4,k+=4,B=1}}return Lt(y,y.e+Kt+1,Pt,c)},we.toExponential=function(c,d){return c!=null&&(H(c,0,1e9),c++),jr(this,c,d,1)},we.toFixed=function(c,d){return c!=null&&(H(c,0,1e9),c=c+this.e+1),jr(this,c,d)},we.toFormat=function(c,d,y){var B;if(y==null)c!=null&&d&&typeof d=="object"?(y=d,d=null):c&&typeof c=="object"?(y=c,c=d=null):y=Fr;else if(typeof y!="object")throw Error(M+"Argument not an object: "+y);if(B=this.toFixed(c,d),this.c){var x,A=B.split("."),k=+y.groupSize,E=+y.secondaryGroupSize,O=y.groupSeparator||"",_=A[0],T=A[1],X=this.s<0,He=X?_.slice(1):_,Ke=He.length;if(E&&(x=k,k=E,E=x,Ke-=x),k>0&&Ke>0){for(x=Ke%k||k,_=He.substr(0,x);x<Ke;x+=k)_+=O+He.substr(x,k);E>0&&(_+=O+He.slice(x)),X&&(_="-"+_)}B=T?_+(y.decimalSeparator||"")+((E=+y.fractionGroupSize)?T.replace(RegExp("\\d{"+E+"}\\B","g"),"$&"+(y.fractionGroupSeparator||"")):T):_}return(y.prefix||"")+B+(y.suffix||"")},we.toFraction=function(c){var d,y,B,x,A,k,E,O,_,T,X,He,Ke=this.c;if(c!=null&&(!(E=new V(c)).isInteger()&&(E.c||E.s!==1)||E.lt(ir)))throw Error(M+"Argument "+(E.isInteger()?"out of range: ":"not an integer: ")+jt(E));if(!Ke)return new V(this);for(d=new V(ir),_=y=new V(ir),B=O=new V(ir),He=Y(Ke),A=d.e=He.length-this.e-1,d.c[0]=L[(k=A%14)<0?14+k:k],c=!c||E.comparedTo(d)>0?A>0?d:_:E,k=Ft,Ft=1/0,E=new V(He),O.c[0]=0;T=wt(E,d,0,1),(x=y.plus(T.times(B))).comparedTo(c)!=1;)y=B,B=x,_=O.plus(T.times(x=_)),O=x,d=E.minus(T.times(x=d)),E=x;return x=wt(c.minus(y),B,0,1),O=O.plus(x.times(_)),y=y.plus(x.times(B)),O.s=_.s=this.s,A*=2,X=1>wt(_,B,A,Pt).minus(this).abs().comparedTo(wt(O,y,A,Pt).minus(this).abs())?[_,B]:[O,y],Ft=k,X},we.toNumber=function(){return+jt(this)},we.toPrecision=function(c,d){return c!=null&&H(c,1,1e9),jr(this,c,d,2)},we.toString=function(c){var d,y=this,B=y.s,x=y.e;return x===null?B?(d="Infinity",B<0&&(d="-"+d)):d="NaN":(c==null?d=x<=sr||x>=fr?Ge(Y(y.c),x):Le(Y(y.c),x,"0"):c===10&&Gt?d=Le(Y((y=Lt(new V(y),Kt+x+1,Pt)).c),y.e,"0"):(H(c,2,ar.length,"Base"),d=Ut(Le(Y(y.c),x,"0"),10,c,B,!0)),B<0&&y.c[0]&&(d="-"+d)),d},we.valueOf=we.toJSON=function(){return jt(this)},we._isBigNumber=!0,we[Symbol.toStringTag]="BigNumber",we[Symbol.for("nodejs.util.inspect.custom")]=we.valueOf,ae!=null&&V.set(ae),V}())("1e+18");var re=de(4270);let w=ie=>{let ae=(0,Oe.av)(32,ie),{encode:Fe,decode:lt}=C(ae);return ae.decode=(Ye,ot)=>{let dt=lt(Ye,ot);return new re.J3(dt)},ae.encode=(Ye,ot,dt)=>Fe(Ye.toBuffer(),ot,dt),ae},v=new re.J3("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new re.J3("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");let z=new re.J3("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new re.J3("So11111111111111111111111111111111111111112"),new re.J3("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class ge extends Error{constructor(ae){super(ae)}}class We extends ge{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}async function xt(ie,ae,Fe=!1,lt=v,Ye=z){if(!Fe&&!re.J3.isOnCurve(ae.toBuffer()))throw new We;let[ot]=await re.J3.findProgramAddress([ae.toBuffer(),lt.toBuffer(),ie.toBuffer()],Ye);return ot}de(5356).Buffer,(0,Oe.w3)([(0,Oe.DH)("mintAuthorityOption"),w("mintAuthority"),F("supply"),(0,Oe.u8)("decimals"),(ie=>{let ae=(0,Oe.u8)(ie),{encode:Fe,decode:lt}=C(ae);return ae.decode=(Ye,ot)=>!!lt(Ye,ot),ae.encode=(Ye,ot,dt)=>Fe(Number(Ye),ot,dt),ae})("isInitialized"),(0,Oe.DH)("freezeAuthorityOption"),w("freezeAuthority")]).span},Wt.__chunk_7106=(At,je,de)=>{"use strict";let Oe=de(2972).v4,xe=de(9921),C=function($,q){if(!(this instanceof C))return new C($,q);q||(q={}),this.options={reviver:q.reviver!==void 0?q.reviver:null,replacer:q.replacer!==void 0?q.replacer:null,generator:q.generator!==void 0?q.generator:function(){return Oe()},version:q.version!==void 0?q.version:2,notificationIdNull:typeof q.notificationIdNull=="boolean"&&q.notificationIdNull},this.callServer=$};At.exports=C,C.prototype.request=function($,q,U,F){let K,R=this,ee=null,M=Array.isArray($)&&typeof q=="function";if(this.options.version===1&&M)throw TypeError("JSON-RPC 1.0 does not support batching");if(M||!M&&$&&typeof $=="object"&&typeof q=="function")F=q,ee=$;else{typeof U=="function"&&(F=U,U=void 0);let L=typeof F=="function";try{ee=xe($,q,U,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(j){if(L)return void F(j);throw j}if(!L)return ee}try{K=JSON.stringify(ee,this.options.replacer)}catch(L){F(L);return}return this.callServer(K,function(L,j){R._parseResponse(L,j,F)}),ee},C.prototype._parseResponse=function($,q,U){let F;if($)return void U($);if(!q)return void U();try{F=JSON.parse(q,this.options.reviver)}catch(K){U(K);return}if(U.length===3)if(Array.isArray(F)){let K=function(R){return R.error!==void 0};U(null,F.filter(K),F.filter(function(R){return!K(R)}));return}else return void U(null,F.error,F.result);U(null,F)}},Wt.__chunk_6264=(At,je,de)=>{"use strict";var Oe=de(5356).Buffer;je.k5=function(xe){{let C=Oe.from(xe);C.reverse();let $=C.toString("hex");return $.length===0?BigInt(0):BigInt(`0x${$}`)}},je.cI=function(xe){{let C=xe.toString("hex");return C.length===0?BigInt(0):BigInt(`0x${C}`)}},je.Bq=function(xe,C){{let $=xe.toString(16),q=Oe.from($.padStart(2*C,"0").slice(0,2*C),"hex");return q.reverse(),q}},je.zy=function(xe,C){{let $=xe.toString(16);return Oe.from($.padStart(2*C,"0").slice(0,2*C),"hex")}}},Wt.__chunk_4270=(At,je,de)=>{"use strict";de.d(je,{Ng:()=>ha,Sr:()=>ya,J3:()=>Ue});var Oe,xe,C=de(5356);let $=typeof on=="object"&&"crypto"in on?on.crypto:void 0;function q(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function U(i){if(!Number.isSafeInteger(i)||i<0)throw Error("positive integer expected, got "+i)}function F(i,...e){if(!q(i))throw Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw Error("Uint8Array expected of length "+e+", got length="+i.length)}function K(i){if(typeof i!="function"||typeof i.create!="function")throw Error("Hash should be wrapped by utils.createHasher");U(i.outputLen),U(i.blockLen)}function R(i,e=!0){if(i.destroyed)throw Error("Hash instance has been destroyed");if(e&&i.finished)throw Error("Hash#digest() has already been called")}function ee(i,e){F(i);let t=e.outputLen;if(i.length<t)throw Error("digestInto() expects output buffer of length at least "+t)}function M(...i){for(let e=0;e<i.length;e++)i[e].fill(0)}function le(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function L(i,e){return i<<32-e|i>>>e}let j=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68?i=>i:function(i){for(let t=0;t<i.length;t++){var e;i[t]=(e=i[t])<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}return i},Y=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ee=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function H(i){if(F(i),Y)return i.toHex();let e="";for(let t=0;t<i.length;t++)e+=Ee[i[t]];return e}let Ce={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ge(i){return i>=Ce._0&&i<=Ce._9?i-Ce._0:i>=Ce.A&&i<=Ce.F?i-(Ce.A-10):i>=Ce.a&&i<=Ce.f?i-(Ce.a-10):void 0}function Le(i){if(typeof i!="string")throw Error("hex string expected, got "+typeof i);if(Y)return Uint8Array.fromHex(i);let e=i.length,t=e/2;if(e%2)throw Error("hex string expected, got unpadded hex of length "+e);let r=new Uint8Array(t);for(let n=0,s=0;n<t;n++,s+=2){let a=Ge(i.charCodeAt(s)),o=Ge(i.charCodeAt(s+1));if(a===void 0||o===void 0)throw Error('hex string expected, got non-hex character "'+(i[s]+i[s+1])+'" at index '+s);r[n]=16*a+o}return r}function re(i){if(typeof i!="string")throw Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}function w(i){return typeof i=="string"&&(i=re(i)),F(i),i}function v(...i){let e=0;for(let r=0;r<i.length;r++){let n=i[r];F(n),e+=n.length}let t=new Uint8Array(e);for(let r=0,n=0;r<i.length;r++){let s=i[r];t.set(s,n),n+=s.length}return t}class z{}function ge(i){let e=r=>i().update(w(r)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function We(i=32){if($&&typeof $.getRandomValues=="function")return $.getRandomValues(new Uint8Array(i));if($&&typeof $.randomBytes=="function")return Uint8Array.from($.randomBytes(i));throw Error("crypto.getRandomValues must be defined")}class xt extends z{constructor(e,t,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(e),this.view=le(this.buffer)}update(e){R(this),F(e=w(e));let{view:t,buffer:r,blockLen:n}=this,s=e.length;for(let a=0;a<s;){let o=Math.min(n-this.pos,s-a);if(o===n){let u=le(e);for(;n<=s-a;a+=n)this.process(u,a);continue}r.set(e.subarray(a,a+o),this.pos),this.pos+=o,a+=o,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){R(this),ee(e,this),this.finished=!0;let{buffer:t,view:r,blockLen:n,isLE:s}=this,{pos:a}=this;t[a++]=128,M(this.buffer.subarray(a)),this.padOffset>n-a&&(this.process(r,0),a=0);for(let m=a;m<n;m++)t[m]=0;(function(m,p,S,l){if(typeof m.setBigUint64=="function")return m.setBigUint64(p,S,l);let h=BigInt(32),P=BigInt(4294967295),W=Number(S>>h&P),Te=Number(S&P),ye=4*!!l,qe=4*!l;m.setUint32(p+ye,W,l),m.setUint32(p+qe,Te,l)})(r,n-8,BigInt(8*this.length),s),this.process(r,0);let o=le(e),u=this.outputLen;if(u%4)throw Error("_sha2: outputLen should be aligned to 32bit");let b=u/4,g=this.get();if(b>g.length)throw Error("_sha2: outputLen bigger than state");for(let m=0;m<b;m++)o.setUint32(4*m,g[m],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:r,length:n,finished:s,destroyed:a,pos:o}=this;return e.destroyed=a,e.finished=s,e.length=n,e.pos=o,n%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}let ie=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ae=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Fe=BigInt(4294967296-1),lt=BigInt(32);function Ye(i,e=!1){let t=i.length,r=new Uint32Array(t),n=new Uint32Array(t);for(let s=0;s<t;s++){let{h:a,l:o}=function(u,b=!1){return b?{h:Number(u&Fe),l:Number(u>>lt&Fe)}:{h:0|Number(u>>lt&Fe),l:0|Number(u&Fe)}}(i[s],e);[r[s],n[s]]=[a,o]}return[r,n]}let ot=(i,e,t)=>i>>>t,dt=(i,e,t)=>i<<32-t|e>>>t,Et=(i,e,t)=>i>>>t|e<<32-t,wt=(i,e,t)=>i<<32-t|e>>>t,Ut=(i,e,t)=>i<<64-t|e>>>t-32,nr=(i,e,t)=>i>>>t-32|e<<64-t;function we(i,e,t,r){let n=(e>>>0)+(r>>>0);return{h:i+t+(n/4294967296|0)|0,l:0|n}}let ir=(i,e,t)=>(i>>>0)+(e>>>0)+(t>>>0),Kt=(i,e,t,r)=>e+t+r+(i/4294967296|0)|0,Pt=(i,e,t,r)=>(i>>>0)+(e>>>0)+(t>>>0)+(r>>>0),sr=(i,e,t,r,n)=>e+t+r+n+(i/4294967296|0)|0,fr=(i,e,t,r,n)=>(i>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),or=(i,e,t,r,n,s)=>e+t+r+n+s+(i/4294967296|0)|0,Ft=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Rt=new Uint32Array(64);class vr extends xt{constructor(e=32){super(64,e,8,!1),this.A=0|ie[0],this.B=0|ie[1],this.C=0|ie[2],this.D=0|ie[3],this.E=0|ie[4],this.F=0|ie[5],this.G=0|ie[6],this.H=0|ie[7]}get(){let{A:e,B:t,C:r,D:n,E:s,F:a,G:o,H:u}=this;return[e,t,r,n,s,a,o,u]}set(e,t,r,n,s,a,o,u){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|a,this.G=0|o,this.H=0|u}process(e,t){for(let h=0;h<16;h++,t+=4)Rt[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){let P=Rt[h-15],W=Rt[h-2],Te=L(P,7)^L(P,18)^P>>>3,ye=L(W,17)^L(W,19)^W>>>10;Rt[h]=ye+Rt[h-7]+Te+Rt[h-16]|0}let{A:r,B:n,C:s,D:a,E:o,F:u,G:b,H:g}=this;for(let h=0;h<64;h++){var m,p,S,l;let P=g+(L(o,6)^L(o,11)^L(o,25))+((m=o)&u^~m&b)+Ft[h]+Rt[h]|0,W=(L(r,2)^L(r,13)^L(r,22))+((p=r)&(S=n)^p&(l=s)^S&l)|0;g=b,b=u,u=o,o=a+P|0,a=s,s=n,n=r,r=P+W|0}r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,a=a+this.D|0,o=o+this.E|0,u=u+this.F|0,b=b+this.G|0,g=g+this.H|0,this.set(r,n,s,a,o,u,b,g)}roundClean(){M(Rt)}destroy(){this.set(0,0,0,0,0,0,0,0),M(this.buffer)}}let Qt=Ye(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(i=>BigInt(i))),Fr=Qt[0],ar=Qt[1],Gt=new Uint32Array(80),V=new Uint32Array(80);class jr extends xt{constructor(e=64){super(128,e,16,!1),this.Ah=0|ae[0],this.Al=0|ae[1],this.Bh=0|ae[2],this.Bl=0|ae[3],this.Ch=0|ae[4],this.Cl=0|ae[5],this.Dh=0|ae[6],this.Dl=0|ae[7],this.Eh=0|ae[8],this.El=0|ae[9],this.Fh=0|ae[10],this.Fl=0|ae[11],this.Gh=0|ae[12],this.Gl=0|ae[13],this.Hh=0|ae[14],this.Hl=0|ae[15]}get(){let{Ah:e,Al:t,Bh:r,Bl:n,Ch:s,Cl:a,Dh:o,Dl:u,Eh:b,El:g,Fh:m,Fl:p,Gh:S,Gl:l,Hh:h,Hl:P}=this;return[e,t,r,n,s,a,o,u,b,g,m,p,S,l,h,P]}set(e,t,r,n,s,a,o,u,b,g,m,p,S,l,h,P){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|a,this.Dh=0|o,this.Dl=0|u,this.Eh=0|b,this.El=0|g,this.Fh=0|m,this.Fl=0|p,this.Gh=0|S,this.Gl=0|l,this.Hh=0|h,this.Hl=0|P}process(e,t){for(let ye=0;ye<16;ye++,t+=4)Gt[ye]=e.getUint32(t),V[ye]=e.getUint32(t+=4);for(let ye=16;ye<80;ye++){let qe=0|Gt[ye-15],ve=0|V[ye-15],De=Et(qe,ve,1)^Et(qe,ve,8)^ot(qe,ve,7),Re=wt(qe,ve,1)^wt(qe,ve,8)^dt(qe,ve,7),Z=0|Gt[ye-2],fe=0|V[ye-2],te=Et(Z,fe,19)^Ut(Z,fe,61)^ot(Z,fe,6),me=Pt(Re,wt(Z,fe,19)^nr(Z,fe,61)^dt(Z,fe,6),V[ye-7],V[ye-16]),Se=sr(me,De,te,Gt[ye-7],Gt[ye-16]);Gt[ye]=0|Se,V[ye]=0|me}let{Ah:r,Al:n,Bh:s,Bl:a,Ch:o,Cl:u,Dh:b,Dl:g,Eh:m,El:p,Fh:S,Fl:l,Gh:h,Gl:P,Hh:W,Hl:Te}=this;for(let ye=0;ye<80;ye++){let qe=Et(m,p,14)^Et(m,p,18)^Ut(m,p,41),ve=wt(m,p,14)^wt(m,p,18)^nr(m,p,41),De=m&S^~m&h,Re=fr(Te,ve,p&l^~p&P,ar[ye],V[ye]),Z=or(Re,W,qe,De,Fr[ye],Gt[ye]),fe=0|Re,te=Et(r,n,28)^Ut(r,n,34)^Ut(r,n,39),me=wt(r,n,28)^nr(r,n,34)^nr(r,n,39),Se=r&s^r&o^s&o,tt=n&a^n&u^a&u;W=0|h,Te=0|P,h=0|S,P=0|l,S=0|m,l=0|p,{h:m,l:p}=we(0|b,0|g,0|Z,0|fe),b=0|o,g=0|u,o=0|s,u=0|a,s=0|r,a=0|n;let Qe=ir(fe,me,tt);r=Kt(Qe,Z,te,Se),n=0|Qe}({h:r,l:n}=we(0|this.Ah,0|this.Al,0|r,0|n)),{h:s,l:a}=we(0|this.Bh,0|this.Bl,0|s,0|a),{h:o,l:u}=we(0|this.Ch,0|this.Cl,0|o,0|u),{h:b,l:g}=we(0|this.Dh,0|this.Dl,0|b,0|g),{h:m,l:p}=we(0|this.Eh,0|this.El,0|m,0|p),{h:S,l}=we(0|this.Fh,0|this.Fl,0|S,0|l),{h,l:P}=we(0|this.Gh,0|this.Gl,0|h,0|P),{h:W,l:Te}=we(0|this.Hh,0|this.Hl,0|W,0|Te),this.set(r,n,s,a,o,u,b,g,m,p,S,l,h,P,W,Te)}roundClean(){M(Gt,V)}destroy(){M(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}let Tr=ge(()=>new vr),Mr=ge(()=>new jr),Lt=BigInt(0),jt=BigInt(1);function c(i,e=""){if(typeof i!="boolean")throw Error((e&&`"${e}"`)+"expected boolean, got type="+typeof i);return i}function d(i,e,t=""){let r=q(i),n=i?.length,s=e!==void 0;if(!r||s&&n!==e)throw Error((t&&`"${t}" `)+"expected Uint8Array"+(s?` of length ${e}`:"")+", got "+(r?`length=${n}`:`type=${typeof i}`));return i}function y(i){let e=i.toString(16);return 1&e.length?"0"+e:e}function B(i){if(typeof i!="string")throw Error("hex string expected, got "+typeof i);return i===""?Lt:BigInt("0x"+i)}function x(i){return F(i),B(H(Uint8Array.from(i).reverse()))}function A(i,e){return Le(i.toString(16).padStart(2*e,"0"))}function k(i,e){return A(i,e).reverse()}function E(i,e,t){let r;if(typeof e=="string")try{r=Le(e)}catch(s){throw Error(i+" must be hex string or Uint8Array, cause: "+s)}else if(q(e))r=Uint8Array.from(e);else throw Error(i+" must be hex string or Uint8Array");let n=r.length;if(typeof t=="number"&&n!==t)throw Error(i+" of length "+t+" expected, got "+n);return r}function O(i){return Uint8Array.from(i)}let _=i=>typeof i=="bigint"&&Lt<=i;function T(i,e,t,r){if(!(_(e)&&_(t)&&_(r))||!(t<=e)||!(e<r))throw Error("expected valid "+i+": "+t+" <= n < "+r+", got "+e)}function X(i){let e;for(e=0;i>Lt;i>>=jt,e+=1);return e}let He=i=>(jt<<BigInt(i))-jt;function Ke(i,e,t={}){if(!i||typeof i!="object")throw Error("expected valid options object");function r(n,s,a){let o=i[n];if(a&&o===void 0)return;let u=typeof o;if(u!==s||o===null)throw Error(`param "${n}" is invalid: expected ${s}, got ${u}`)}Object.entries(e).forEach(([n,s])=>r(n,s,!1)),Object.entries(t).forEach(([n,s])=>r(n,s,!0))}let mt=()=>{throw Error("not implemented")};function ct(i){let e=new WeakMap;return(t,...r)=>{let n=e.get(t);if(n!==void 0)return n;let s=i(t,...r);return e.set(t,s),s}}let Je=BigInt(0),Me=BigInt(1),St=BigInt(2),Sr=BigInt(3),xr=BigInt(4),Cr=BigInt(5),Vr=BigInt(7),Mt=BigInt(8),Rr=BigInt(9),qt=BigInt(16);function it(i,e){let t=i%e;return t>=Je?t:e+t}function Ve(i,e,t){let r=i;for(;e-- >Je;)r*=r,r%=t;return r}function ri(i,e){if(i===Je)throw Error("invert: expected non-zero number");if(e<=Je)throw Error("invert: expected positive modulus, got "+e);let t=it(i,e),r=e,n=Je,s=Me,a=Me,o=Je;for(;t!==Je;){let u=r/t,b=r%t,g=n-a*u,m=s-o*u;r=t,t=b,n=a,s=o,a=g,o=m}if(r!==Me)throw Error("invert: does not exist");return it(n,e)}function vn(i,e,t){if(!i.eql(i.sqr(e),t))throw Error("Cannot find square root")}function ni(i,e){let t=(i.ORDER+Me)/xr,r=i.pow(e,t);return vn(i,r,e),r}function ps(i,e){let t=(i.ORDER-Cr)/Mt,r=i.mul(e,St),n=i.pow(r,t),s=i.mul(e,n),a=i.mul(i.mul(s,St),n),o=i.mul(s,i.sub(a,i.ONE));return vn(i,o,e),o}function ii(i){if(i<Sr)throw Error("sqrt is not defined for small field");let e=i-Me,t=0;for(;e%St===Je;)e/=St,t++;let r=St,n=gr(i);for(;oi(n,r)===1;)if(r++>1e3)throw Error("Cannot find square root: probably non-prime P");if(t===1)return ni;let s=n.pow(r,e),a=(e+Me)/St;return function(o,u){if(o.is0(u))return u;if(oi(o,u)!==1)throw Error("Cannot find square root");let b=t,g=o.mul(o.ONE,s),m=o.pow(u,e),p=o.pow(u,a);for(;!o.eql(m,o.ONE);){if(o.is0(m))return o.ZERO;let S=1,l=o.sqr(m);for(;!o.eql(l,o.ONE);)if(S++,l=o.sqr(l),S===b)throw Error("Cannot find square root");let h=Me<<BigInt(b-S-1),P=o.pow(g,h);b=S,g=o.sqr(P),m=o.mul(m,g),p=o.mul(p,P)}return p}}let pr=(i,e)=>(it(i,e)&Me)===Me,gs=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function si(i,e,t=!1){let r=Array(e.length).fill(t?i.ZERO:void 0),n=e.reduce((a,o,u)=>i.is0(o)?a:(r[u]=a,i.mul(a,o)),i.ONE),s=i.inv(n);return e.reduceRight((a,o,u)=>i.is0(o)?a:(r[u]=i.mul(a,r[u]),i.mul(a,o)),s),r}function oi(i,e){let t=(i.ORDER-Me)/St,r=i.pow(e,t),n=i.eql(r,i.ONE),s=i.eql(r,i.ZERO),a=i.eql(r,i.neg(i.ONE));if(!n&&!s&&!a)throw Error("invalid Legendre symbol result");return n?1:s?0:-1}function ai(i,e){e!==void 0&&U(e);let t=e!==void 0?e:i.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function gr(i,e,t=!1,r={}){let n,s,a,o;if(i<=Je)throw Error("invalid field: expected ORDER > 0, got "+i);let u=!1;if(typeof e=="object"&&e!=null){if(r.sqrt||t)throw Error("cannot specify opts in two arguments");e.BITS&&(s=e.BITS),e.sqrt&&(a=e.sqrt),typeof e.isLE=="boolean"&&(t=e.isLE),typeof e.modFromBytes=="boolean"&&(u=e.modFromBytes),o=e.allowedLengths}else typeof e=="number"&&(s=e),r.sqrt&&(a=r.sqrt);let{nBitLength:b,nByteLength:g}=ai(i,s);if(g>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let m=Object.freeze({ORDER:i,isLE:t,BITS:b,BYTES:g,MASK:He(b),ZERO:Je,ONE:Me,allowedLengths:o,create:p=>it(p,i),isValid:p=>{if(typeof p!="bigint")throw Error("invalid field element: expected bigint, got "+typeof p);return Je<=p&&p<i},is0:p=>p===Je,isValidNot0:p=>!m.is0(p)&&m.isValid(p),isOdd:p=>(p&Me)===Me,neg:p=>it(-p,i),eql:(p,S)=>p===S,sqr:p=>it(p*p,i),add:(p,S)=>it(p+S,i),sub:(p,S)=>it(p-S,i),mul:(p,S)=>it(p*S,i),pow:(p,S)=>function(l,h,P){if(P<Je)throw Error("invalid exponent, negatives unsupported");if(P===Je)return l.ONE;if(P===Me)return h;let W=l.ONE,Te=h;for(;P>Je;)P&Me&&(W=l.mul(W,Te)),Te=l.sqr(Te),P>>=Me;return W}(m,p,S),div:(p,S)=>it(p*ri(S,i),i),sqrN:p=>p*p,addN:(p,S)=>p+S,subN:(p,S)=>p-S,mulN:(p,S)=>p*S,inv:p=>ri(p,i),sqrt:a||(p=>(n||(n=i%xr===Sr?ni:i%Mt===Cr?ps:i%qt===Rr?function(S){let l=gr(S),h=ii(S),P=h(l,l.neg(l.ONE)),W=h(l,P),Te=h(l,l.neg(P)),ye=(S+Vr)/qt;return(qe,ve)=>{let De=qe.pow(ve,ye),Re=qe.mul(De,P),Z=qe.mul(De,W),fe=qe.mul(De,Te),te=qe.eql(qe.sqr(Re),ve),me=qe.eql(qe.sqr(Z),ve);De=qe.cmov(De,Re,te),Re=qe.cmov(fe,Z,me);let Se=qe.eql(qe.sqr(Re),ve),tt=qe.cmov(De,Re,Se);return vn(qe,tt,ve),tt}}(i):ii(i)),n(m,p))),toBytes:p=>t?k(p,g):A(p,g),fromBytes:(p,S=!0)=>{if(o){if(!o.includes(p.length)||p.length>g)throw Error("Field.fromBytes: expected "+o+" bytes, got "+p.length);let h=new Uint8Array(g);h.set(p,t?0:h.length-p.length),p=h}if(p.length!==g)throw Error("Field.fromBytes: expected "+g+" bytes, got "+p.length);let l=t?x(p):B(H(p));if(u&&(l=it(l,i)),!S&&!m.isValid(l))throw Error("invalid field element: outside of range 0..ORDER");return l},invertBatch:p=>si(m,p),cmov:(p,S,l)=>l?S:p});return Object.freeze(m)}function ci(i){if(typeof i!="bigint")throw Error("field order must be bigint");return Math.ceil(i.toString(2).length/8)}function ui(i){let e=ci(i);return e+Math.ceil(e/2)}let Lr=BigInt(0),Er=BigInt(1);function an(i,e){let t=e.negate();return i?t:e}function Ir(i,e){let t=si(i.Fp,e.map(r=>r.Z));return e.map((r,n)=>i.fromAffine(r.toAffine(t[n])))}function li(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw Error("invalid window size, expected [1.."+e+"], got W="+i)}function Sn(i,e){li(i,e);let t=Math.ceil(e/i)+1,r=2**(i-1),n=2**i;return{windows:t,windowSize:r,mask:He(i),maxNumber:n,shiftBy:BigInt(i)}}function di(i,e,t){let{windowSize:r,mask:n,maxNumber:s,shiftBy:a}=t,o=Number(i&n),u=i>>a;o>r&&(o-=s,u+=Er);let b=e*r,g=b+Math.abs(o)-1;return{nextN:u,offset:g,isZero:o===0,isNeg:o<0,isNegF:e%2!=0,offsetF:b}}let xn=new WeakMap,hi=new WeakMap;function En(i){return hi.get(i)||1}function fi(i){if(i!==Lr)throw Error("invalid wNAF")}class pi{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>Lr;)t&Er&&(r=r.add(n)),n=n.double(),t>>=Er;return r}precomputeWindow(e,t){let{windows:r,windowSize:n}=Sn(t,this.bits),s=[],a=e,o=a;for(let u=0;u<r;u++){o=a,s.push(o);for(let b=1;b<n;b++)o=o.add(a),s.push(o);a=o.double()}return s}wNAF(e,t,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let n=this.ZERO,s=this.BASE,a=Sn(e,this.bits);for(let o=0;o<a.windows;o++){let{nextN:u,offset:b,isZero:g,isNeg:m,isNegF:p,offsetF:S}=di(r,o,a);r=u,g?s=s.add(an(p,t[S])):n=n.add(an(m,t[b]))}return fi(r),{p:n,f:s}}wNAFUnsafe(e,t,r,n=this.ZERO){let s=Sn(e,this.bits);for(let a=0;a<s.windows&&r!==Lr;a++){let{nextN:o,offset:u,isZero:b,isNeg:g}=di(r,a,s);if(r=o,!b){let m=t[u];n=n.add(g?m.negate():m)}}return fi(r),n}getPrecomputes(e,t,r){let n=xn.get(t);return n||(n=this.precomputeWindow(t,e),e!==1&&(typeof r=="function"&&(n=r(n)),xn.set(t,n))),n}cached(e,t,r){let n=En(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){let s=En(e);return s===1?this._unsafeLadder(e,t,n):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,n)}createCache(e,t){li(t,this.bits),hi.set(e,t),xn.delete(e)}hasCache(e){return En(e)!==1}}function In(i,e,t,r){if(!Array.isArray(t))throw Error("array expected");if(t.forEach((S,l)=>{if(!(S instanceof i))throw Error("invalid point at index "+l)}),!Array.isArray(r))throw Error("array of scalars expected");r.forEach((S,l)=>{if(!e.isValid(S))throw Error("invalid scalar at index "+l)});let n=t.length,s=r.length;if(n!==s)throw Error("arrays of points and scalars must have equal length");let a=i.ZERO,o=X(BigInt(n)),u=1;o>12?u=o-3:o>4?u=o-2:o>0&&(u=2);let b=He(u),g=Array(Number(b)+1).fill(a),m=Math.floor((e.BITS-1)/u)*u,p=a;for(let S=m;S>=0;S-=u){g.fill(a);for(let h=0;h<s;h++){let P=Number(r[h]>>BigInt(S)&b);g[P]=g[P].add(t[h])}let l=a;for(let h=g.length-1,P=a;h>0;h--)P=P.add(g[h]),l=l.add(P);if(p=p.add(l),S!==0)for(let h=0;h<u;h++)p=p.double()}return p}function gi(i,e,t){if(!e)return gr(i,{isLE:t});if(e.ORDER!==i)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return Ke(e,gs.reduce((r,n)=>(r[n]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"})),e}function mi(i,e,t={},r){if(r===void 0&&(r=i==="edwards"),!e||typeof e!="object")throw Error(`expected valid ${i} CURVE object`);for(let a of["p","n","h"]){let o=e[a];if(!(typeof o=="bigint"&&o>Lr))throw Error(`CURVE.${a} must be positive bigint`)}let n=gi(e.p,t.Fp,r),s=gi(e.n,t.Fn,r);for(let a of["Gx","Gy","a",i==="weierstrass"?"b":"d"])if(!n.isValid(e[a]))throw Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:n,Fn:s}}let mr=BigInt(0),Ot=BigInt(1),Bn=BigInt(2),ms=BigInt(8);class ys{constructor(e){this.ep=e}static fromBytes(e){mt()}static fromHex(e){mt()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return H(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,t){return this.init(this.ep.precompute(e,t))}toRawBytes(){return this.toBytes()}}re("HashToScalar-");let bs=BigInt(0),cr=BigInt(1),yi=BigInt(2);BigInt(3);let ws=BigInt(5),ks=BigInt(8),Xe=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),$r={p:Xe,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:ks,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")},Gr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function An(i,e){let t=it(e*e*e,Xe),r=function(m){let p=BigInt(10),S=BigInt(20),l=BigInt(40),h=BigInt(80),P=m*m%Xe*m%Xe,W=Ve(P,yi,Xe)*P%Xe,Te=Ve(W,cr,Xe)*m%Xe,ye=Ve(Te,ws,Xe)*Te%Xe,qe=Ve(ye,p,Xe)*ye%Xe,ve=Ve(qe,S,Xe)*qe%Xe,De=Ve(ve,l,Xe)*ve%Xe,Re=Ve(De,h,Xe)*De%Xe,Z=Ve(Re,h,Xe)*De%Xe,fe=Ve(Z,p,Xe)*ye%Xe;return{pow_p_5_8:Ve(fe,yi,Xe)*m%Xe,b2:P}}(i*it(t*t*e,Xe)).pow_p_5_8,n=it(i*t*r,Xe),s=it(e*n*n,Xe),a=n,o=it(n*Gr,Xe),u=s===i,b=s===it(-i,Xe),g=s===it(-i*Gr,Xe);return u&&(n=a),(b||g)&&(n=o),pr(n,Xe)&&(n=it(-n,Xe)),{isValid:u||b,value:n}}let yr=gr($r.p,{isLE:!0}),vs=gr($r.n,{isLE:!0}),Vt=function(i){let{CURVE:e,curveOpts:t,hash:r,eddsaOpts:n}=function(o){let u={a:o.a,d:o.d,p:o.Fp.ORDER,n:o.n,h:o.h,Gx:o.Gx,Gy:o.Gy},b={Fp:o.Fp,Fn:gr(u.n,o.nBitLength,!0),uvRatio:o.uvRatio},g={randomBytes:o.randomBytes,adjustScalarBytes:o.adjustScalarBytes,domain:o.domain,prehash:o.prehash,mapToCurve:o.mapToCurve};return{CURVE:u,curveOpts:b,hash:o.hash,eddsaOpts:g}}(i),s=function(o,u,b={}){if(typeof u!="function")throw Error('"hash" function param is required');Ke(b,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:g}=b,{BASE:m,Fp:p,Fn:S}=o,l=b.randomBytes||We,h=b.adjustScalarBytes||(te=>te),P=b.domain||((te,me,Se)=>{if(c(Se,"phflag"),me.length||Se)throw Error("Contexts/pre-hash are not supported");return te});function W(te){return S.create(x(te))}function Te(te){let{head:me,prefix:Se,scalar:tt}=function(pt){let gt=Re.secretKey;pt=E("private key",pt,gt);let G=E("hashed private key",u(pt),2*gt),pe=h(G.slice(0,gt)),ze=G.slice(gt,2*gt),_e=W(pe);return{head:pe,prefix:ze,scalar:_e}}(te),Qe=m.multiply(tt),ft=Qe.toBytes();return{head:me,prefix:Se,scalar:tt,point:Qe,pointBytes:ft}}function ye(te){return Te(te).pointBytes}function qe(te=Uint8Array.of(),...me){return W(u(P(v(...me),E("context",te),!!g)))}let ve={zip215:!0},De=p.BYTES,Re={secretKey:De,publicKey:De,signature:2*De,seed:De};function Z(te=l(Re.seed)){return d(te,Re.seed,"seed")}let fe={getExtendedPublicKey:Te,randomSecretKey:Z,isValidSecretKey:function(te){return q(te)&&te.length===S.BYTES},isValidPublicKey:function(te,me){try{return!!o.fromBytes(te,me)}catch{return!1}},toMontgomery(te){let{y:me}=o.fromBytes(te),Se=Re.publicKey,tt=Se===32;if(!tt&&Se!==57)throw Error("only defined for 25519 and 448");let Qe=tt?p.div(Ot+me,Ot-me):p.div(me-Ot,me+Ot);return p.toBytes(Qe)},toMontgomerySecret(te){let me=Re.secretKey;return d(te,me),h(u(te.subarray(0,me))).subarray(0,me)},randomPrivateKey:Z,precompute:(te=8,me=o.BASE)=>me.precompute(te,!1)};return Object.freeze({keygen:function(te){let me=fe.randomSecretKey(te);return{secretKey:me,publicKey:ye(me)}},getPublicKey:ye,sign:function(te,me,Se={}){te=E("message",te),g&&(te=g(te));let{prefix:tt,scalar:Qe,pointBytes:ft}=Te(me),pt=qe(Se.context,tt,te),gt=m.multiply(pt).toBytes(),G=qe(Se.context,gt,ft,te),pe=S.create(pt+G*Qe);if(!S.isValid(pe))throw Error("sign failed: invalid s");return d(v(gt,S.toBytes(pe)),Re.signature,"result")},verify:function(te,me,Se,tt=ve){let Qe,ft,pt,{context:gt,zip215:G}=tt,pe=Re.signature;te=E("signature",te,pe),me=E("message",me),Se=E("publicKey",Se,Re.publicKey),G!==void 0&&c(G,"zip215"),g&&(me=g(me));let ze=pe/2,_e=te.subarray(0,ze),N=x(te.subarray(ze,pe));try{Qe=o.fromBytes(Se,G),ft=o.fromBytes(_e,G),pt=m.multiplyUnsafe(N)}catch{return!1}if(!G&&Qe.isSmallOrder())return!1;let J=qe(gt,ft.toBytes(),Qe.toBytes(),me);return ft.add(Qe.multiplyUnsafe(J)).subtract(pt).clearCofactor().is0()},utils:fe,Point:o,lengths:Re})}(function(o,u={}){let b=mi("edwards",o,u,u.FpFnLE),{Fp:g,Fn:m}=b,p=b.CURVE,{h:S}=p;Ke(u,{},{uvRatio:"function"});let l=Bn<<BigInt(8*m.BYTES)-Ot,h=Re=>g.create(Re),P=u.uvRatio||((Re,Z)=>{try{return{isValid:!0,value:g.sqrt(g.div(Re,Z))}}catch{return{isValid:!1,value:mr}}});if(!function(Re,Z,fe,te){let me=Re.sqr(fe),Se=Re.sqr(te),tt=Re.add(Re.mul(Z.a,me),Se),Qe=Re.add(Re.ONE,Re.mul(Z.d,Re.mul(me,Se)));return Re.eql(tt,Qe)}(g,p,p.Gx,p.Gy))throw Error("bad curve params: generator point");function W(Re,Z,fe=!1){return T("coordinate "+Re,Z,fe?Ot:mr,l),Z}function Te(Re){if(!(Re instanceof ve))throw Error("ExtendedPoint expected")}let ye=ct((Re,Z)=>{let{X:fe,Y:te,Z:me}=Re,Se=Re.is0();Z==null&&(Z=Se?ms:g.inv(me));let tt=h(fe*Z),Qe=h(te*Z),ft=g.mul(me,Z);if(Se)return{x:mr,y:Ot};if(ft!==Ot)throw Error("invZ was invalid");return{x:tt,y:Qe}}),qe=ct(Re=>{let{a:Z,d:fe}=p;if(Re.is0())throw Error("bad point: ZERO");let{X:te,Y:me,Z:Se,T:tt}=Re,Qe=h(te*te),ft=h(me*me),pt=h(Se*Se),gt=h(pt*pt),G=h(Qe*Z);if(h(pt*h(G+ft))!==h(gt+h(fe*h(Qe*ft))))throw Error("bad point: equation left != right (1)");if(h(te*me)!==h(Se*tt))throw Error("bad point: equation left != right (2)");return!0});class ve{constructor(Z,fe,te,me){this.X=W("x",Z),this.Y=W("y",fe),this.Z=W("z",te,!0),this.T=W("t",me),Object.freeze(this)}static CURVE(){return p}static fromAffine(Z){if(Z instanceof ve)throw Error("extended point not allowed");let{x:fe,y:te}=Z||{};return W("x",fe),W("y",te),new ve(fe,te,Ot,h(fe*te))}static fromBytes(Z,fe=!1){let te=g.BYTES,{a:me,d:Se}=p;Z=O(d(Z,te,"point")),c(fe,"zip215");let tt=O(Z),Qe=Z[te-1];tt[te-1]=-129&Qe;let ft=x(tt);T("point.y",ft,mr,fe?l:g.ORDER);let pt=h(ft*ft),{isValid:gt,value:G}=P(h(pt-Ot),h(Se*pt-me));if(!gt)throw Error("bad point: invalid y coordinate");let pe=(G&Ot)===Ot,ze=(128&Qe)!=0;if(!fe&&G===mr&&ze)throw Error("bad point: x=0 and x_0=1");return ze!==pe&&(G=h(-G)),ve.fromAffine({x:G,y:ft})}static fromHex(Z,fe=!1){return ve.fromBytes(E("point",Z),fe)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Z=8,fe=!0){return De.createCache(this,Z),fe||this.multiply(Bn),this}assertValidity(){qe(this)}equals(Z){Te(Z);let{X:fe,Y:te,Z:me}=this,{X:Se,Y:tt,Z:Qe}=Z,ft=h(fe*Qe),pt=h(Se*me),gt=h(te*Qe),G=h(tt*me);return ft===pt&&gt===G}is0(){return this.equals(ve.ZERO)}negate(){return new ve(h(-this.X),this.Y,this.Z,h(-this.T))}double(){let{a:Z}=p,{X:fe,Y:te,Z:me}=this,Se=h(fe*fe),tt=h(te*te),Qe=h(Bn*h(me*me)),ft=h(Z*Se),pt=fe+te,gt=h(h(pt*pt)-Se-tt),G=ft+tt,pe=G-Qe,ze=ft-tt,_e=h(gt*pe),N=h(G*ze),J=h(gt*ze);return new ve(_e,N,h(pe*G),J)}add(Z){Te(Z);let{a:fe,d:te}=p,{X:me,Y:Se,Z:tt,T:Qe}=this,{X:ft,Y:pt,Z:gt,T:G}=Z,pe=h(me*ft),ze=h(Se*pt),_e=h(Qe*te*G),N=h(tt*gt),J=h((me+Se)*(ft+pt)-pe-ze),ke=N-_e,Pe=N+_e,be=h(ze-fe*pe),oe=h(J*ke),se=h(Pe*be),he=h(J*be);return new ve(oe,se,h(ke*Pe),he)}subtract(Z){return this.add(Z.negate())}multiply(Z){if(!m.isValidNot0(Z))throw Error("invalid scalar: expected 1 <= sc < curve.n");let{p:fe,f:te}=De.cached(this,Z,me=>Ir(ve,me));return Ir(ve,[fe,te])[0]}multiplyUnsafe(Z,fe=ve.ZERO){if(!m.isValid(Z))throw Error("invalid scalar: expected 0 <= sc < curve.n");return Z===mr?ve.ZERO:this.is0()||Z===Ot?this:De.unsafe(this,Z,te=>Ir(ve,te),fe)}isSmallOrder(){return this.multiplyUnsafe(S).is0()}isTorsionFree(){return De.unsafe(this,p.n).is0()}toAffine(Z){return ye(this,Z)}clearCofactor(){return S===Ot?this:this.multiplyUnsafe(S)}toBytes(){let{x:Z,y:fe}=this.toAffine(),te=g.toBytes(fe);return te[te.length-1]|=Z&Ot?128:0,te}toHex(){return H(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(Z){return Ir(ve,Z)}static msm(Z,fe){return In(ve,m,Z,fe)}_setWindowSize(Z){this.precompute(Z)}toRawBytes(){return this.toBytes()}}ve.BASE=new ve(p.Gx,p.Gy,Ot,h(p.Gx*p.Gy)),ve.ZERO=new ve(mr,Ot,Ot,mr),ve.Fp=g,ve.Fn=m;let De=new pi(ve,m.BITS);return ve.BASE.precompute(8),ve}(e,t),r,n),a=s.Point;return Object.assign({},s,{ExtendedPoint:a,CURVE:i,nBitLength:a.Fn.BITS,nByteLength:a.Fn.BYTES})}({...$r,Fp:yr,hash:Mr,adjustScalarBytes:function(i){return i[0]&=248,i[31]&=127,i[31]|=64,i},uvRatio:An}),Ss=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),xs=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),Es=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Is=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),bi=i=>An(cr,i),Bs=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),_n=i=>Vt.Point.Fp.create(x(i)&Bs);function wi(i){let{d:e}=$r,t=P=>yr.create(P),r=t(Gr*i*i),n=t((r+cr)*Es),s=BigInt(-1),a=t((s-e*r)*t(r+e)),{isValid:o,value:u}=An(n,a),b=t(u*i);pr(b,Xe)||(b=t(-b)),o||(u=b),o||(s=r);let g=t(s*(r-cr)*Is-a),m=u*u,p=t((u+u)*a),S=t(g*Ss),l=t(cr-m),h=t(cr+m);return new Vt.Point(t(p*h),t(l*S),t(S*h),t(p*l))}class Dt extends ys{constructor(e){super(e)}static fromAffine(e){return new Dt(Vt.Point.fromAffine(e))}assertSame(e){if(!(e instanceof Dt))throw Error("RistrettoPoint expected")}init(e){return new Dt(e)}static hashToCurve(e){var t=E("ristrettoHash",e,64);F(t,64);let r=wi(_n(t.subarray(0,32))),n=wi(_n(t.subarray(32,64)));return new Dt(r.add(n))}static fromBytes(e){F(e,32);let{a:t,d:r}=$r,n=ye=>yr.create(ye),s=_n(e);if(!function(ye,qe){if(ye.length!==qe.length)return!1;let ve=0;for(let De=0;De<ye.length;De++)ve|=ye[De]^qe[De];return ve===0}(yr.toBytes(s),e)||pr(s,Xe))throw Error("invalid ristretto255 encoding 1");let a=n(s*s),o=n(cr+t*a),u=n(cr-t*a),b=n(o*o),g=n(u*u),m=n(t*r*b-g),{isValid:p,value:S}=bi(n(m*g)),l=n(S*u),h=n(S*l*m),P=n((s+s)*l);pr(P,Xe)&&(P=n(-P));let W=n(o*h),Te=n(P*W);if(!p||pr(Te,Xe)||W===bs)throw Error("invalid ristretto255 encoding 2");return new Dt(new Vt.Point(P,W,cr,Te))}static fromHex(e){return Dt.fromBytes(E("ristrettoHex",e,32))}static msm(e,t){return In(Dt,Vt.Point.Fn,e,t)}toBytes(){let e,{X:t,Y:r,Z:n,T:s}=this.ep,a=h=>yr.create(h),o=a(a(n+r)*a(n-r)),u=a(t*r),b=a(u*u),{value:g}=bi(a(o*b)),m=a(g*o),p=a(g*u),S=a(m*p*s);if(pr(s*S,Xe)){let h=a(r*Gr),P=a(t*Gr);t=h,r=P,e=a(m*xs)}else e=p;pr(t*S,Xe)&&(r=a(-r));let l=a((n-r)*e);return pr(l,Xe)&&(l=a(-l)),yr.toBytes(l)}equals(e){this.assertSame(e);let{X:t,Y:r}=this.ep,{X:n,Y:s}=e.ep,a=b=>yr.create(b),o=a(t*s)===a(r*n),u=a(r*s)===a(t*n);return o||u}is0(){return this.equals(Dt.ZERO)}}Dt.BASE=new Dt(Vt.Point.BASE),Dt.ZERO=new Dt(Vt.Point.ZERO),Dt.Fp=yr,Dt.Fn=vs;var As=de(1748),ki=de.n(As),_s=de(3550),Ct=de.n(_s),Pn=de(6239),f=de(3537);function Ps([i,e]){return`${i}=${function t(r){return Array.isArray(r)?"%5B"+r.map(t).join("%2C%20")+"%5D":typeof r=="bigint"?`${r}n`:encodeURIComponent(String(r!=null&&Object.getPrototypeOf(r)===null?{...r}:r))}(e)}`}var Nr=class extends Error{cause=this.cause;context;constructor(...[i,e]){let t,r;if(e){let{cause:n,...s}=e;n&&(r={cause:n}),Object.keys(s).length>0&&(t=s)}super(function(n,s={}){{let a=`Solana error #${n}; Decode this error by running \`npx @solana/errors decode -- ${n}`;return Object.keys(s).length&&(a+=` '${btoa(Object.entries(s).map(Ps).join("&"))}'`),`${a}\``}}(i,t),r),this.context={__code:i,...t},this.name="SolanaError"}};function zr(i){return"fixedSize"in i&&typeof i.fixedSize=="number"}var Os=(i=>(i[i.Little=0]="Little",i[i.Big=1]="Big",i))(Os||{});function vi(i){return i?.endian!==1}var Si=(i={})=>function(e){var t;return Object.freeze({...t={fixedSize:e.size,write(r,n,s){e.range&&function(o,u,b,g){if(g<u||g>b)throw new Nr(8078011,{codecDescription:o,max:b,min:u,value:g})}(e.name,e.range[0],e.range[1],r);let a=new ArrayBuffer(e.size);return e.set(new DataView(a),r,vi(e.config)),n.set(new Uint8Array(a),s),s+e.size}},encode:r=>{let n=new Uint8Array("fixedSize"in t?t.fixedSize:t.getSizeFromValue(r));return t.write(r,n,0),n}})}({config:i,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,r)=>e.setBigUint64(0,BigInt(t),r),size:8});class Ts extends TypeError{constructor(e,t){let r,{message:n,explanation:s,...a}=e,{path:o}=e,u=o.length===0?n:`At path: ${o.join(".")} -- ${n}`;super(s??u),s!=null&&(this.cause=u),Object.assign(this,a),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function Zr(i){return typeof i=="object"&&i!=null}function cn(i){return Zr(i)&&!Array.isArray(i)}function er(i){return typeof i=="symbol"?i.toString():typeof i=="string"?JSON.stringify(i):`${i}`}function*xi(i,e,t,r){var n;for(let s of(Zr(n=i)&&typeof n[Symbol.iterator]=="function"||(i=[i]),i)){let a=function(o,u,b,g){if(o===!0)return;o===!1?o={}:typeof o=="string"&&(o={message:o});let{path:m,branch:p}=u,{type:S}=b,{refinement:l,message:h=`Expected a value of type \`${S}\`${l?` with refinement \`${l}\``:""}, but received: \`${er(g)}\``}=o;return{value:g,type:S,refinement:l,key:m[m.length-1],path:m,branch:p,...o,message:h}}(s,e,t,r);a&&(yield a)}}function*On(i,e,t={}){let{path:r=[],branch:n=[i],coerce:s=!1,mask:a=!1}=t,o={path:r,branch:n,mask:a};s&&(i=e.coercer(i,o));let u="valid";for(let b of e.validator(i,o))b.explanation=t.message,u="not_valid",yield[b,void 0];for(let[b,g,m]of e.entries(i,o))for(let p of On(g,m,{path:b===void 0?r:[...r,b],branch:b===void 0?n:[...n,g],coerce:s,mask:a,message:t.message}))p[0]?(u=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):s&&(g=p[1],b===void 0?i=g:i instanceof Map?i.set(b,g):i instanceof Set?i.add(g):Zr(i)&&(g!==void 0||b in i)&&(i[b]=g));if(u!=="not_valid")for(let b of e.refiner(i,o))b.explanation=t.message,u="not_refined",yield[b,void 0];u==="valid"&&(yield[void 0,i])}class tr{constructor(e){let{type:t,schema:r,validator:n,refiner:s,coercer:a=u=>u,entries:o=function*(){}}=e;this.type=t,this.schema=r,this.entries=o,this.coercer=a,n?this.validator=(u,b)=>xi(n(u,b),b,this,u):this.validator=()=>[],s?this.refiner=(u,b)=>xi(s(u,b),b,this,u):this.refiner=()=>[]}assert(e,t){var r=e,n=this,s=t;let a=Wr(r,n,{message:s});if(a[0])throw a[0]}create(e,t){return ne(e,this,t)}is(e){var t,r;return t=e,r=this,!Wr(t,r)[0]}mask(e,t){var r=e,n=this,s=t;let a=Wr(r,n,{coerce:!0,mask:!0,message:s});if(!a[0])return a[1];throw a[0]}validate(e,t={}){return Wr(e,this,t)}}function ne(i,e,t){let r=Wr(i,e,{coerce:!0,message:t});if(!r[0])return r[1];throw r[0]}function Wr(i,e,t={}){let r=On(i,e,t),n=function(s){let{done:a,value:o}=s.next();return a?void 0:o}(r);return n[0]?[new Ts(n[0],function*(){for(let s of r)s[0]&&(yield s[0])}),void 0]:[void 0,n[1]]}function Br(i,e){return new tr({type:i,schema:null,validator:e})}function ce(i){return new tr({type:"array",schema:i,*entries(e){if(i&&Array.isArray(e))for(let[t,r]of e.entries())yield[t,r,i]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${er(e)}`})}function rr(){return Br("boolean",i=>typeof i=="boolean")}function Tn(i){return Br("instance",e=>e instanceof i||`Expected a \`${i.name}\` instance, but received: ${er(e)}`)}function It(i){let e=er(i),t=typeof i;return new tr({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?i:null,validator:r=>r===i||`Expected the literal \`${e}\`, but received: ${er(r)}`})}function ue(i){return new tr({...i,validator:(e,t)=>e===null||i.validator(e,t),refiner:(e,t)=>e===null||i.refiner(e,t)})}function I(){return Br("number",i=>typeof i=="number"&&!isNaN(i)||`Expected a number, but received: ${er(i)}`)}function Ne(i){return new tr({...i,validator:(e,t)=>e===void 0||i.validator(e,t),refiner:(e,t)=>e===void 0||i.refiner(e,t)})}function Ei(i,e){return new tr({type:"record",schema:null,*entries(t){if(Zr(t))for(let r in t){let n=t[r];yield[r,r,i],yield[r,n,e]}},validator:t=>cn(t)||`Expected an object, but received: ${er(t)}`,coercer:t=>cn(t)?{...t}:t})}function Q(){return Br("string",i=>typeof i=="string"||`Expected a string, but received: ${er(i)}`)}function Cn(i){let e=Br("never",()=>!1);return new tr({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let r=Math.max(i.length,t.length);for(let n=0;n<r;n++)yield[n,t[n],i[n]||e]}},validator:t=>Array.isArray(t)||`Expected an array, but received: ${er(t)}`,coercer:t=>Array.isArray(t)?t.slice():t})}function D(i){let e=Object.keys(i);return new tr({type:"type",schema:i,*entries(t){if(Zr(t))for(let r of e)yield[r,t[r],i[r]]},validator:t=>cn(t)||`Expected an object, but received: ${er(t)}`,coercer:t=>cn(t)?{...t}:t})}function Ht(i){let e=i.map(t=>t.type).join(" | ");return new tr({type:"union",schema:null,coercer(t,r){for(let n of i){let[s,a]=n.validate(t,{coerce:!0,mask:r.mask});if(!s)return a}return t},validator(t,r){let n=[];for(let s of i){let[...a]=On(t,s,r),[o]=a;if(!o[0])return[];for(let[u]of a)u&&n.push(u)}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${er(t)}`,...n]}})}function Ur(){return Br("unknown",()=>!0)}function Yr(i,e,t){return new tr({...i,coercer:(r,n)=>Wr(r,e)[0]?i.coercer(r,n):i.coercer(t(r,n),n)})}var Cs=de(7106),Rs=de.n(Cs),Ii=de(2975),Ls=class extends Ii{socket;constructor(i,e){super(),this.socket=new window.WebSocket(i,e.protocols),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=t=>this.emit("message",t.data),this.socket.onerror=t=>this.emit("error",t),this.socket.onclose=t=>{this.emit("close",t.code,t.reason)}}send(i,e,t){let r=t||e;try{this.socket.send(i),r()}catch(n){r(n)}}close(i,e){this.socket.close(i,e)}addEventListener(i,e,t){this.socket.addEventListener(i,e,t)}},Ns=class{encode(i){return JSON.stringify(i)}decode(i){return JSON.parse(i)}},zs=class extends Ii{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(i,e="ws://localhost:8080",{autoconnect:t=!0,reconnect:r=!0,reconnect_interval:n=1e3,max_reconnects:s=5,...a}={},o,u){super(),this.webSocketFactory=i,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=t,this.ready=!1,this.reconnect=r,this.reconnect_timer_id=void 0,this.reconnect_interval=n,this.max_reconnects=s,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=o||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),u?this.dataPack=u:this.dataPack=new Ns,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(i,e,t,r){return r||typeof t!="object"||(r=t,t=null),new Promise((n,s)=>{if(!this.ready)return s(Error("socket not ready"));let a=this.generate_request_id(i,e);this.socket.send(this.dataPack.encode({jsonrpc:"2.0",method:i,params:e||void 0,id:a}),r,o=>{if(o)return s(o);this.queue[a]={promise:[n,s]},t&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],s(Error("reply timeout"))},t))})})}async login(i){let e=await this.call("rpc.login",i);if(!e)throw Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(i,e){return new Promise((t,r)=>{if(!this.ready)return r(Error("socket not ready"));this.socket.send(this.dataPack.encode({jsonrpc:"2.0",method:i,params:e}),n=>{if(n)return r(n);t()})})}async subscribe(i){typeof i=="string"&&(i=[i]);let e=await this.call("rpc.on",i);if(typeof i=="string"&&e[i]!=="ok")throw Error("Failed subscribing to an event '"+i+"' with: "+e[i]);return e}async unsubscribe(i){typeof i=="string"&&(i=[i]);let e=await this.call("rpc.off",i);if(typeof i=="string"&&e[i]!=="ok")throw Error("Failed unsubscribing from an event with: "+e);return e}close(i,e){this.socket&&this.socket.close(i||1e3,e)}setAutoReconnect(i){this.reconnect=i}setReconnectInterval(i){this.reconnect_interval=i}setMaxReconnects(i){this.max_reconnects=i}getCurrentReconnects(){return this.current_reconnects}getMaxReconnects(){return this.max_reconnects}isReconnecting(){return this.reconnect_timer_id!==void 0}willReconnect(){return this.reconnect&&(this.max_reconnects===0||this.current_reconnects<this.max_reconnects)}_connect(i,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(i,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:t})=>{t instanceof ArrayBuffer&&(t=C.Buffer.from(t).toString());try{t=this.dataPack.decode(t)}catch{return}if(t.notification&&this.listeners(t.notification).length){if(!Object.keys(t.params).length)return this.emit(t.notification);let r=[t.notification];if(t.params.constructor===Object)r.push(t.params);else for(let n=0;n<t.params.length;n++)r.push(t.params[n]);return Promise.resolve().then(()=>{this.emit.apply(this,r)})}if(!this.queue[t.id])return t.method?Promise.resolve().then(()=>{this.emit(t.method,t?.params)}):void 0;"error"in t=="result"in t&&this.queue[t.id].promise[1](Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[t.id].timeout&&clearTimeout(this.queue[t.id].timeout),t.error?this.queue[t.id].promise[1](t.error):this.queue[t.id].promise[0](t.result),delete this.queue[t.id]}),this.socket.addEventListener("error",t=>this.emit("error",t)),this.socket.addEventListener("close",({code:t,reason:r})=>{this.ready&&setTimeout(()=>this.emit("close",t,r),0),this.ready=!1,this.socket=void 0,t!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)?this.reconnect_timer_id=setTimeout(()=>this._connect(i,e),this.reconnect_interval):this.reconnect&&this.max_reconnects>0&&this.current_reconnects>=this.max_reconnects&&setTimeout(()=>this.emit("max_reconnects_reached",t,r),1))})}};let Ws=BigInt(0),Xr=BigInt(1),Us=BigInt(2),qs=BigInt(7),Ds=BigInt(256),Hs=BigInt(113),Bi=[],Ai=[],_i=[];for(let i=0,e=Xr,t=1,r=0;i<24;i++){[t,r]=[r,(2*t+3*r)%5],Bi.push(2*(5*r+t)),Ai.push((i+1)*(i+2)/2%64);let n=Ws;for(let s=0;s<7;s++)(e=(e<<Xr^(e>>qs)*Hs)%Ds)&Us&&(n^=Xr<<(Xr<<BigInt(s))-Xr);_i.push(n)}let Pi=Ye(_i,!0),Ks=Pi[0],Fs=Pi[1],Oi=(i,e,t)=>t>32?((r,n,s)=>n<<s-32|r>>>64-s)(i,e,t):((r,n,s)=>r<<s|n>>>32-s)(i,e,t),Ti=(i,e,t)=>t>32?((r,n,s)=>r<<s-32|n>>>64-s)(i,e,t):((r,n,s)=>n<<s|r>>>32-s)(i,e,t);class Rn extends z{constructor(e,t,r,n=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=s,U(r),!(0<e&&e<200))throw Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=function(a){return new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4))}(this.state)}clone(){return this._cloneInto()}keccak(){j(this.state32),function(e,t=24){let r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){let u=(o+8)%10,b=(o+2)%10,g=r[b],m=r[b+1],p=Oi(g,m,1)^r[u],S=Ti(g,m,1)^r[u+1];for(let l=0;l<50;l+=10)e[o+l]^=p,e[o+l+1]^=S}let s=e[2],a=e[3];for(let o=0;o<24;o++){let u=Ai[o],b=Oi(s,a,u),g=Ti(s,a,u),m=Bi[o];s=e[m],a=e[m+1],e[m]=b,e[m+1]=g}for(let o=0;o<50;o+=10){for(let u=0;u<10;u++)r[u]=e[o+u];for(let u=0;u<10;u++)e[o+u]^=~r[(u+2)%10]&r[(u+4)%10]}e[0]^=Ks[n],e[1]^=Fs[n]}M(r)}(this.state32,this.rounds),j(this.state32),this.posOut=0,this.pos=0}update(e){R(this),F(e=w(e));let{blockLen:t,state:r}=this,n=e.length;for(let s=0;s<n;){let a=Math.min(t-this.pos,n-s);for(let o=0;o<a;o++)r[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,(128&t)!=0&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){R(this,!1),F(e),this.finish();let t=this.state,{blockLen:r}=this;for(let n=0,s=e.length;n<s;){this.posOut>=r&&this.keccak();let a=Math.min(r-this.posOut,s-n);e.set(t.subarray(this.posOut,this.posOut+a),n),this.posOut+=a,n+=a}return e}xofInto(e){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return U(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ee(e,this),this.finished)throw Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,M(this.state)}_cloneInto(e){let{blockLen:t,suffix:r,outputLen:n,rounds:s,enableXOF:a}=this;return e||(e=new Rn(t,r,n,a,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=r,e.outputLen=n,e.enableXOF=a,e.destroyed=this.destroyed,e}}let Ci=(()=>ge(()=>new Rn(136,1,32)))();class Ri extends z{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,K(e);let r=w(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=e.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),M(s)}update(e){return R(this),this.iHash.update(e),this}digestInto(e){R(this),F(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:a,outputLen:o}=this;return e.finished=n,e.destroyed=s,e.blockLen=a,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}let Li=(i,e,t)=>new Ri(i,e).update(t).digest();Li.create=(i,e)=>new Ri(i,e);let Ni=(i,e)=>(i+(i>=0?e:-e)/zi)/e;function Ln(i){if(!["compact","recovered","der"].includes(i))throw Error('Signature format must be "compact", "recovered", or "der"');return i}function Nn(i,e){let t={};for(let r of Object.keys(e))t[r]=i[r]===void 0?e[r]:i[r];return c(t.lowS,"lowS"),c(t.prehash,"prehash"),t.format!==void 0&&Ln(t.format),t}class js extends Error{constructor(e=""){super(e)}}let ur={Err:js,_tlv:{encode:(i,e)=>{let{Err:t}=ur;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(1&e.length)throw new t("tlv.encode: unpadded data");let r=e.length/2,n=y(r);if(n.length/2&128)throw new t("tlv.encode: long form length too big");let s=r>127?y(n.length/2|128):"";return y(i)+s+n+e},decode(i,e){let{Err:t}=ur,r=0;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==i)throw new t("tlv.decode: wrong tlv");let n=e[r++],s=0;if(128&n){let o=127&n;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");let u=e.subarray(r,r+o);if(u.length!==o)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let b of u)s=s<<8|b;if(r+=o,s<128)throw new t("tlv.decode(long): not minimal encoding")}else s=n;let a=e.subarray(r,r+s);if(a.length!==s)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+s)}}},_int:{encode(i){let{Err:e}=ur;if(i<lr)throw new e("integer: negative integers are not allowed");let t=y(i);if(8&Number.parseInt(t[0],16)&&(t="00"+t),1&t.length)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(i){let{Err:e}=ur;if(128&i[0])throw new e("invalid signature integer: negative");if(i[0]===0&&!(128&i[1]))throw new e("invalid signature integer: unnecessary leading zero");return B(H(i))}},toSig(i){let{Err:e,_int:t,_tlv:r}=ur,n=E("signature",i),{v:s,l:a}=r.decode(48,n);if(a.length)throw new e("invalid signature: left bytes after parsing");let{v:o,l:u}=r.decode(2,s),{v:b,l:g}=r.decode(2,u);if(g.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(o),s:t.decode(b)}},hexFromSig(i){let{_tlv:e,_int:t}=ur,r=e.encode(2,t.encode(i.r)),n=e.encode(2,t.encode(i.s));return e.encode(48,r+n)}},lr=BigInt(0),Ar=BigInt(1),zi=BigInt(2),un=BigInt(3),Ms=BigInt(4);function qr(i,e){let t,{BYTES:r}=i;if(typeof e=="bigint")t=e;else{let n=E("private key",e);try{t=i.fromBytes(n)}catch{throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!i.isValidNot0(t))throw Error("invalid private key: out of range [1..N-1]");return t}function Wi(i){return Uint8Array.of(i?2:3)}function Ui(i,e){return{secretKey:e.BYTES,publicKey:1+i.BYTES,publicKeyUncompressed:1+2*i.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}let zn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Vs={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},qi=BigInt(2),Wn=gr(zn.p,{sqrt:function(i){let e=zn.p,t=BigInt(3),r=BigInt(6),n=BigInt(11),s=BigInt(22),a=BigInt(23),o=BigInt(44),u=BigInt(88),b=i*i*i%e,g=b*b*i%e,m=Ve(g,t,e)*g%e,p=Ve(m,t,e)*g%e,S=Ve(p,qi,e)*b%e,l=Ve(S,n,e)*S%e,h=Ve(l,s,e)*l%e,P=Ve(h,o,e)*h%e,W=Ve(P,u,e)*P%e,Te=Ve(W,o,e)*h%e,ye=Ve(Te,t,e)*g%e,qe=Ve(ye,a,e)*l%e,ve=Ve(qe,r,e)*b%e,De=Ve(ve,qi,e);if(!Wn.eql(Wn.sqr(De),i))throw Error("Cannot find square root");return De}}),Un=function(i,e){let t=r=>function(n){let{CURVE:s,curveOpts:a,hash:o,ecdsaOpts:u}=function(m){let{CURVE:p,curveOpts:S}=function(h){let P={a:h.a,b:h.b,p:h.Fp.ORDER,n:h.n,h:h.h,Gx:h.Gx,Gy:h.Gy},W=h.Fp,Te=h.allowedPrivateKeyLengths?Array.from(new Set(h.allowedPrivateKeyLengths.map(qe=>Math.ceil(qe/2)))):void 0,ye={Fp:W,Fn:gr(P.n,{BITS:h.nBitLength,allowedLengths:Te,modFromBytes:h.wrapPrivateKey}),allowInfinityPoint:h.allowInfinityPoint,endo:h.endo,isTorsionFree:h.isTorsionFree,clearCofactor:h.clearCofactor,fromBytes:h.fromBytes,toBytes:h.toBytes};return{CURVE:P,curveOpts:ye}}(m),l={hmac:m.hmac,randomBytes:m.randomBytes,lowS:m.lowS,bits2int:m.bits2int,bits2int_modN:m.bits2int_modN};return{CURVE:p,curveOpts:S,hash:m.hash,ecdsaOpts:l}}(n),b=function(m,p,S={}){K(p),Ke(S,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let l=S.randomBytes||We,h=S.hmac||((G,...pe)=>Li(p,G,v(...pe))),{Fp:P,Fn:W}=m,{ORDER:Te,BITS:ye}=W,{keygen:qe,getPublicKey:ve,getSharedSecret:De,utils:Re,lengths:Z}=function(G,pe={}){let{Fn:ze}=G,_e=pe.randomBytes||We,N=Object.assign(Ui(G.Fp,ze),{seed:ui(ze.ORDER)});function J(oe){try{return!!qr(ze,oe)}catch{return!1}}function ke(oe=_e(N.seed)){return function(se,he,Ie=!1){let Be=se.length,rt=ci(he),st=ui(he);if(Be<16||Be<st||Be>1024)throw Error("expected "+st+"-1024 bytes of input, got "+Be);let $e=it(Ie?x(se):B(H(se)),he-Me)+Me;return Ie?k($e,rt):A($e,rt)}(d(oe,N.seed,"seed"),ze.ORDER)}function Pe(oe,se=!0){return G.BASE.multiply(qr(ze,oe)).toBytes(se)}function be(oe){if(typeof oe=="bigint")return!1;if(oe instanceof G)return!0;let{secretKey:se,publicKey:he,publicKeyUncompressed:Ie}=N;if(ze.allowedLengths||se===he)return;let Be=E("key",oe).length;return Be===he||Be===Ie}return Object.freeze({getPublicKey:Pe,getSharedSecret:function(oe,se,he=!0){if(be(oe)===!0)throw Error("first arg must be private key");if(be(se)===!1)throw Error("second arg must be public key");let Ie=qr(ze,oe);return G.fromHex(se).multiply(Ie).toBytes(he)},keygen:function(oe){let se=ke(oe);return{secretKey:se,publicKey:Pe(se)}},Point:G,utils:{isValidSecretKey:J,isValidPublicKey:function(oe,se){let{publicKey:he,publicKeyUncompressed:Ie}=N;try{let Be=oe.length;return se===!0&&Be!==he||se===!1&&Be!==Ie?!1:!!G.fromBytes(oe)}catch{return!1}},randomSecretKey:ke,isValidPrivateKey:J,randomPrivateKey:ke,normPrivateKeyToScalar:oe=>qr(ze,oe),precompute:(oe=8,se=G.BASE)=>se.precompute(oe,!1)},lengths:N})}(m,S),fe={prehash:!1,lowS:typeof S.lowS=="boolean"&&S.lowS,format:void 0,extraEntropy:!1},te="compact";function me(G,pe){if(!W.isValidNot0(pe))throw Error(`invalid signature ${G}: out of range 1..Point.Fn.ORDER`);return pe}class Se{constructor(pe,ze,_e){this.r=me("r",pe),this.s=me("s",ze),_e!=null&&(this.recovery=_e),Object.freeze(this)}static fromBytes(pe,ze=te){let _e;if(function(Pe,be){Ln(be);let oe=Z.signature;d(Pe,be==="compact"?oe:be==="recovered"?oe+1:void 0,`${be} signature`)}(pe,ze),ze==="der"){let{r:Pe,s:be}=ur.toSig(d(pe));return new Se(Pe,be)}ze==="recovered"&&(_e=pe[0],ze="compact",pe=pe.subarray(1));let N=W.BYTES,J=pe.subarray(0,N),ke=pe.subarray(N,2*N);return new Se(W.fromBytes(J),W.fromBytes(ke),_e)}static fromHex(pe,ze){return this.fromBytes(Le(pe),ze)}addRecoveryBit(pe){return new Se(this.r,this.s,pe)}recoverPublicKey(pe){let ze=P.ORDER,{r:_e,s:N,recovery:J}=this;if(J==null||![0,1,2,3].includes(J))throw Error("recovery id invalid");if(Te*zi<ze&&J>1)throw Error("recovery id is ambiguous for h>1 curve");let ke=J===2||J===3?_e+Te:_e;if(!P.isValid(ke))throw Error("recovery id 2 or 3 invalid");let Pe=P.toBytes(ke),be=m.fromBytes(v(Wi((1&J)==0),Pe)),oe=W.inv(ke),se=Qe(E("msgHash",pe)),he=W.create(-se*oe),Ie=W.create(N*oe),Be=m.BASE.multiplyUnsafe(he).add(be.multiplyUnsafe(Ie));if(Be.is0())throw Error("point at infinify");return Be.assertValidity(),Be}hasHighS(){return this.s>Te>>Ar}toBytes(pe=te){if(Ln(pe),pe==="der")return Le(ur.hexFromSig(this));let ze=W.toBytes(this.r),_e=W.toBytes(this.s);if(pe==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return v(Uint8Array.of(this.recovery),ze,_e)}return v(ze,_e)}toHex(pe){return H(this.toBytes(pe))}assertValidity(){}static fromCompact(pe){return Se.fromBytes(E("sig",pe),"compact")}static fromDER(pe){return Se.fromBytes(E("sig",pe),"der")}normalizeS(){return this.hasHighS()?new Se(this.r,W.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return H(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return H(this.toBytes("compact"))}}let tt=S.bits2int||function(G){if(G.length>8192)throw Error("input is too large");let pe=B(H(G)),ze=8*G.length-ye;return ze>0?pe>>BigInt(ze):pe},Qe=S.bits2int_modN||function(G){return W.create(tt(G))},ft=He(ye);function pt(G){return T("num < 2^"+ye,G,lr,ft),W.toBytes(G)}function gt(G,pe){return d(G,void 0,"message"),pe?d(p(G),void 0,"prehashed message"):G}return Object.freeze({keygen:qe,getPublicKey:ve,getSharedSecret:De,utils:Re,lengths:Z,Point:m,sign:function(G,pe,ze={}){let{seed:_e,k2sig:N}=function(J,ke,Pe){if(["recovered","canonical"].some(rt=>rt in Pe))throw Error("sign() legacy options not supported");let{lowS:be,prehash:oe,extraEntropy:se}=Nn(Pe,fe),he=Qe(J=gt(J,oe)),Ie=qr(W,ke),Be=[pt(Ie),pt(he)];if(se!=null&&se!==!1){let rt=se===!0?l(Z.secretKey):se;Be.push(E("extraEntropy",rt))}return{seed:v(...Be),k2sig:function(rt){let st=tt(rt);if(!W.isValidNot0(st))return;let $e=W.inv(st),nt=m.BASE.multiply(st).toAffine(),vt=W.create(nt.x);if(vt===lr)return;let zt=W.create($e*W.create(he+vt*Ie));if(zt===lr)return;let Tt=2*(nt.x!==vt)|Number(nt.y&Ar),$t=zt;return be&&zt>Te>>Ar&&($t=W.neg(zt),Tt^=1),new Se(vt,$t,Tt)}}}(G=E("message",G),pe,ze);return function(J,ke,Pe){if(typeof J!="number"||J<2)throw Error("hashLen must be a number");if(typeof ke!="number"||ke<2)throw Error("qByteLen must be a number");if(typeof Pe!="function")throw Error("hmacFn must be a function");let be=nt=>new Uint8Array(nt),oe=nt=>Uint8Array.of(nt),se=be(J),he=be(J),Ie=0,Be=()=>{se.fill(1),he.fill(0),Ie=0},rt=(...nt)=>Pe(he,se,...nt),st=(nt=be(0))=>{he=rt(oe(0),nt),se=rt(),nt.length!==0&&(he=rt(oe(1),nt),se=rt())},$e=()=>{if(Ie++>=1e3)throw Error("drbg: tried 1000 values");let nt=0,vt=[];for(;nt<ke;){let zt=(se=rt()).slice();vt.push(zt),nt+=se.length}return v(...vt)};return(nt,vt)=>{let zt;for(Be(),st(nt);!(zt=vt($e()));)st();return Be(),zt}}(p.outputLen,W.BYTES,h)(_e,N)},verify:function(G,pe,ze,_e={}){let{lowS:N,prehash:J,format:ke}=Nn(_e,fe);if(ze=E("publicKey",ze),pe=gt(E("message",pe),J),"strict"in _e)throw Error("options.strict was renamed to lowS");let Pe=ke===void 0?function(be){let oe,se=typeof be=="string"||q(be),he=!se&&be!==null&&typeof be=="object"&&typeof be.r=="bigint"&&typeof be.s=="bigint";if(!se&&!he)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(he)oe=new Se(be.r,be.s);else if(se){try{oe=Se.fromBytes(E("sig",be),"der")}catch(Ie){if(!(Ie instanceof ur.Err))throw Ie}if(!oe)try{oe=Se.fromBytes(E("sig",be),"compact")}catch{return!1}}return!!oe&&oe}(G):Se.fromBytes(E("sig",G),ke);if(Pe===!1)return!1;try{let be=m.fromBytes(ze);if(N&&Pe.hasHighS())return!1;let{r:oe,s:se}=Pe,he=Qe(pe),Ie=W.inv(se),Be=W.create(he*Ie),rt=W.create(oe*Ie),st=m.BASE.multiplyUnsafe(Be).add(be.multiplyUnsafe(rt));return st.is0()?!1:W.create(st.x)===oe}catch{return!1}},recoverPublicKey:function(G,pe,ze={}){let{prehash:_e}=Nn(ze,fe);return pe=gt(pe,_e),Se.fromBytes(G,"recovered").recoverPublicKey(pe).toBytes()},Signature:Se,hash:p})}(function(m,p={}){let S=mi("weierstrass",m,p),{Fp:l,Fn:h}=S,P=S.CURVE,{h:W,n:Te}=P;Ke(p,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:ye}=p;if(ye&&(!l.is0(P.a)||typeof ye.beta!="bigint"||!Array.isArray(ye.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let qe=Ui(l,h);function ve(){if(!l.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let De=p.toBytes||function(_e,N,J){let{x:ke,y:Pe}=N.toAffine(),be=l.toBytes(ke);return c(J,"isCompressed"),J?(ve(),v(Wi(!l.isOdd(Pe)),be)):v(Uint8Array.of(4),be,l.toBytes(Pe))},Re=p.fromBytes||function(_e){d(_e,void 0,"Point");let{publicKey:N,publicKeyUncompressed:J}=qe,ke=_e.length,Pe=_e[0],be=_e.subarray(1);if(ke===N&&(Pe===2||Pe===3)){let oe,se=l.fromBytes(be);if(!l.isValid(se))throw Error("bad point: is not on curve, wrong x");let he=Z(se);try{oe=l.sqrt(he)}catch(Ie){throw Error("bad point: is not on curve, sqrt error"+(Ie instanceof Error?": "+Ie.message:""))}return ve(),(1&Pe)==1!==l.isOdd(oe)&&(oe=l.neg(oe)),{x:se,y:oe}}if(ke===J&&Pe===4){let oe=l.BYTES,se=l.fromBytes(be.subarray(0,oe)),he=l.fromBytes(be.subarray(oe,2*oe));if(!fe(se,he))throw Error("bad point: is not on curve");return{x:se,y:he}}throw Error(`bad point: got length ${ke}, expected compressed=${N} or uncompressed=${J}`)};function Z(_e){let N=l.sqr(_e),J=l.mul(N,_e);return l.add(l.add(J,l.mul(_e,P.a)),P.b)}function fe(_e,N){let J=l.sqr(N),ke=Z(_e);return l.eql(J,ke)}if(!fe(P.Gx,P.Gy))throw Error("bad curve params: generator point");let te=l.mul(l.pow(P.a,un),Ms),me=l.mul(l.sqr(P.b),BigInt(27));if(l.is0(l.add(te,me)))throw Error("bad curve params: a or b");function Se(_e,N,J=!1){if(!l.isValid(N)||J&&l.is0(N))throw Error(`bad point coordinate ${_e}`);return N}function tt(_e){if(!(_e instanceof G))throw Error("ProjectivePoint expected")}function Qe(_e){if(!ye||!ye.basises)throw Error("no endo");return function(N,J,ke){let[[Pe,be],[oe,se]]=J,he=Ni(se*N,ke),Ie=Ni(-be*N,ke),Be=N-he*Pe-Ie*oe,rt=-he*be-Ie*se,st=Be<lr,$e=rt<lr;st&&(Be=-Be),$e&&(rt=-rt);let nt=He(Math.ceil(X(ke)/2))+Ar;if(Be<lr||Be>=nt||rt<lr||rt>=nt)throw Error("splitScalar (endomorphism): failed, k="+N);return{k1neg:st,k1:Be,k2neg:$e,k2:rt}}(_e,ye.basises,h.ORDER)}let ft=ct((_e,N)=>{let{X:J,Y:ke,Z:Pe}=_e;if(l.eql(Pe,l.ONE))return{x:J,y:ke};let be=_e.is0();N==null&&(N=be?l.ONE:l.inv(Pe));let oe=l.mul(J,N),se=l.mul(ke,N),he=l.mul(Pe,N);if(be)return{x:l.ZERO,y:l.ZERO};if(!l.eql(he,l.ONE))throw Error("invZ was invalid");return{x:oe,y:se}}),pt=ct(_e=>{if(_e.is0()){if(p.allowInfinityPoint&&!l.is0(_e.Y))return;throw Error("bad point: ZERO")}let{x:N,y:J}=_e.toAffine();if(!l.isValid(N)||!l.isValid(J))throw Error("bad point: x or y not field elements");if(!fe(N,J))throw Error("bad point: equation left != right");if(!_e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function gt(_e,N,J,ke,Pe){return J=new G(l.mul(J.X,_e),J.Y,J.Z),N=an(ke,N),J=an(Pe,J),N.add(J)}class G{constructor(N,J,ke){this.X=Se("x",N),this.Y=Se("y",J,!0),this.Z=Se("z",ke),Object.freeze(this)}static CURVE(){return P}static fromAffine(N){let{x:J,y:ke}=N||{};if(!N||!l.isValid(J)||!l.isValid(ke))throw Error("invalid affine point");if(N instanceof G)throw Error("projective point not allowed");return l.is0(J)&&l.is0(ke)?G.ZERO:new G(J,ke,l.ONE)}static fromBytes(N){let J=G.fromAffine(Re(d(N,void 0,"point")));return J.assertValidity(),J}static fromHex(N){return G.fromBytes(E("pointHex",N))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(N=8,J=!0){return ze.createCache(this,N),J||this.multiply(un),this}assertValidity(){pt(this)}hasEvenY(){let{y:N}=this.toAffine();if(!l.isOdd)throw Error("Field doesn't support isOdd");return!l.isOdd(N)}equals(N){tt(N);let{X:J,Y:ke,Z:Pe}=this,{X:be,Y:oe,Z:se}=N,he=l.eql(l.mul(J,se),l.mul(be,Pe)),Ie=l.eql(l.mul(ke,se),l.mul(oe,Pe));return he&&Ie}negate(){return new G(this.X,l.neg(this.Y),this.Z)}double(){let{a:N,b:J}=P,ke=l.mul(J,un),{X:Pe,Y:be,Z:oe}=this,se=l.ZERO,he=l.ZERO,Ie=l.ZERO,Be=l.mul(Pe,Pe),rt=l.mul(be,be),st=l.mul(oe,oe),$e=l.mul(Pe,be);return $e=l.add($e,$e),Ie=l.mul(Pe,oe),Ie=l.add(Ie,Ie),se=l.mul(N,Ie),he=l.mul(ke,st),he=l.add(se,he),se=l.sub(rt,he),he=l.add(rt,he),he=l.mul(se,he),se=l.mul($e,se),Ie=l.mul(ke,Ie),st=l.mul(N,st),$e=l.sub(Be,st),$e=l.mul(N,$e),$e=l.add($e,Ie),Ie=l.add(Be,Be),Be=l.add(Ie,Be),Be=l.add(Be,st),Be=l.mul(Be,$e),he=l.add(he,Be),st=l.mul(be,oe),st=l.add(st,st),Be=l.mul(st,$e),se=l.sub(se,Be),Ie=l.mul(st,rt),Ie=l.add(Ie,Ie),new G(se,he,Ie=l.add(Ie,Ie))}add(N){tt(N);let{X:J,Y:ke,Z:Pe}=this,{X:be,Y:oe,Z:se}=N,he=l.ZERO,Ie=l.ZERO,Be=l.ZERO,rt=P.a,st=l.mul(P.b,un),$e=l.mul(J,be),nt=l.mul(ke,oe),vt=l.mul(Pe,se),zt=l.add(J,ke),Tt=l.add(be,oe);zt=l.mul(zt,Tt),Tt=l.add($e,nt),zt=l.sub(zt,Tt),Tt=l.add(J,Pe);let $t=l.add(be,se);return Tt=l.mul(Tt,$t),$t=l.add($e,vt),Tt=l.sub(Tt,$t),$t=l.add(ke,Pe),he=l.add(oe,se),$t=l.mul($t,he),he=l.add(nt,vt),$t=l.sub($t,he),Be=l.mul(rt,Tt),he=l.mul(st,vt),Be=l.add(he,Be),he=l.sub(nt,Be),Be=l.add(nt,Be),Ie=l.mul(he,Be),nt=l.add($e,$e),nt=l.add(nt,$e),vt=l.mul(rt,vt),Tt=l.mul(st,Tt),nt=l.add(nt,vt),vt=l.sub($e,vt),vt=l.mul(rt,vt),Tt=l.add(Tt,vt),$e=l.mul(nt,Tt),Ie=l.add(Ie,$e),$e=l.mul($t,Tt),he=l.mul(zt,he),he=l.sub(he,$e),$e=l.mul(zt,nt),Be=l.mul($t,Be),new G(he,Ie,Be=l.add(Be,$e))}subtract(N){return this.add(N.negate())}is0(){return this.equals(G.ZERO)}multiply(N){let J,ke,{endo:Pe}=p;if(!h.isValidNot0(N))throw Error("invalid scalar: out of range");let be=oe=>ze.cached(this,oe,se=>Ir(G,se));if(Pe){let{k1neg:oe,k1:se,k2neg:he,k2:Ie}=Qe(N),{p:Be,f:rt}=be(se),{p:st,f:$e}=be(Ie);ke=rt.add($e),J=gt(Pe.beta,Be,st,oe,he)}else{let{p:oe,f:se}=be(N);J=oe,ke=se}return Ir(G,[J,ke])[0]}multiplyUnsafe(N){let{endo:J}=p;if(!h.isValid(N))throw Error("invalid scalar: out of range");if(N===lr||this.is0())return G.ZERO;if(N===Ar)return this;if(ze.hasCache(this))return this.multiply(N);if(!J)return ze.unsafe(this,N);{let{k1neg:ke,k1:Pe,k2neg:be,k2:oe}=Qe(N),{p1:se,p2:he}=function(Ie,Be,rt,st){let $e=Be,nt=Ie.ZERO,vt=Ie.ZERO;for(;rt>Lr||st>Lr;)rt&Er&&(nt=nt.add($e)),st&Er&&(vt=vt.add($e)),$e=$e.double(),rt>>=Er,st>>=Er;return{p1:nt,p2:vt}}(G,this,Pe,oe);return gt(J.beta,se,he,ke,be)}}multiplyAndAddUnsafe(N,J,ke){let Pe=this.multiplyUnsafe(J).add(N.multiplyUnsafe(ke));return Pe.is0()?void 0:Pe}toAffine(N){return ft(this,N)}isTorsionFree(){let{isTorsionFree:N}=p;return W===Ar||(N?N(G,this):ze.unsafe(this,Te).is0())}clearCofactor(){let{clearCofactor:N}=p;return W===Ar?this:N?N(G,this):this.multiplyUnsafe(W)}isSmallOrder(){return this.multiplyUnsafe(W).is0()}toBytes(N=!0){return c(N,"isCompressed"),this.assertValidity(),De(G,this,N)}toHex(N=!0){return H(this.toBytes(N))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(N=!0){return this.toBytes(N)}_setWindowSize(N){this.precompute(N)}static normalizeZ(N){return Ir(G,N)}static msm(N,J){return In(G,h,N,J)}static fromPrivateKey(N){return G.BASE.multiply(qr(h,N))}}G.BASE=new G(P.Gx,P.Gy,l.ONE),G.ZERO=new G(l.ZERO,l.ONE,l.ZERO),G.Fp=l,G.Fn=h;let pe=h.BITS,ze=new pi(G,p.endo?Math.ceil(pe/2):pe);return G.BASE.precompute(8),G}(s,a),o,u),g=b.Point;return Object.assign({},b,{ProjectivePoint:g,CURVE:Object.assign({},n,ai(g.Fn.ORDER,g.Fn.BITS))})}({...i,hash:r});return{...t(e),create:t}}({...zn,Fp:Wn,lowS:!0,endo:Vs},Tr);Vt.utils.randomPrivateKey;let Di=()=>{let i=Vt.utils.randomPrivateKey(),e=qn(i),t=new Uint8Array(64);return t.set(i),t.set(e,32),{publicKey:e,secretKey:t}},qn=Vt.getPublicKey;function Hi(i){try{return Vt.ExtendedPoint.fromHex(i),!0}catch{return!1}}let Ki=(i,e)=>Vt.sign(i,e.slice(0,32)),$s=Vt.verify,at=i=>C.Buffer.isBuffer(i)?i:i instanceof Uint8Array?C.Buffer.from(i.buffer,i.byteOffset,i.byteLength):C.Buffer.from(i);class Gs{constructor(e){Object.assign(this,e)}encode(){return C.Buffer.from((0,Pn.serialize)(ln,this))}static decode(e){return(0,Pn.deserialize)(ln,this,e)}static decodeUnchecked(e){return(0,Pn.deserializeUnchecked)(ln,this,e)}}let ln=new Map,Fi=1;class Ue extends Gs{constructor(e){if(super({}),this._bn=void 0,e._bn!==void 0)this._bn=e._bn;else{if(typeof e=="string"){let t=Ct().decode(e);if(t.length!=32)throw Error("Invalid public key input");this._bn=new(ki())(t)}else this._bn=new(ki())(e);if(this._bn.byteLength()>32)throw Error("Invalid public key input")}}static unique(){let e=new Ue(Fi);return Fi+=1,new Ue(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Ct().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(C.Buffer);if(e.length===32)return e;let t=C.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){return new Ue(Tr(C.Buffer.concat([e.toBuffer(),C.Buffer.from(t),r.toBuffer()])))}static createProgramAddressSync(e,t){let r=C.Buffer.alloc(0);e.forEach(function(s){if(s.length>32)throw TypeError("Max seed length exceeded");r=C.Buffer.concat([r,at(s)])});let n=Tr(r=C.Buffer.concat([r,t.toBuffer(),C.Buffer.from("ProgramDerivedAddress")]));if(Hi(n))throw Error("Invalid seeds, address must fall off the curve");return new Ue(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,n=255;for(;n!=0;){try{let s=e.concat(C.Buffer.from([n]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;n--;continue}return[r,n]}throw Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return Hi(new Ue(e).toBytes())}}Ue.default=new Ue("11111111111111111111111111111111"),ln.set(Ue,{kind:"struct",fields:[["_bn","u256"]]}),new Ue("BPFLoader1111111111111111111111111111111111");class ji extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ji.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Mi extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Mi.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Jr extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Jr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class dn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw Error("Account index overflow encountered during compilation");let t=new Map;this.keySegments().flat().forEach((n,s)=>{t.set(n.toBase58(),s)});let r=n=>{let s=t.get(n.toBase58());if(s===void 0)throw Error("Encountered an unknown instruction account key during compilation");return s};return e.map(n=>({programIdIndex:r(n.programId),accountKeyIndexes:n.keys.map(s=>r(s.pubkey)),data:n.data}))}}let et=(i="publicKey")=>f.av(32,i),Dr=(i="string")=>{let e=f.w3([f.DH("length"),f.DH("lengthPadding"),f.av(f.cY(f.DH(),-8),"chars")],i),t=e.decode.bind(e),r=e.encode.bind(e);return e.decode=(n,s)=>t(n,s).chars.toString(),e.encode=(n,s,a)=>r({chars:C.Buffer.from(n,"utf8")},s,a),e.alloc=n=>f.DH().span+f.DH().span+C.Buffer.from(n,"utf8").length,e};function Zt(i){let e=0,t=0;for(;;){let r=i.shift();if(e|=(127&r)<<7*t,t+=1,(128&r)==0)break}return e}function Yt(i,e){let t=e;for(;;){let r=127&t;if((t>>=7)==0){i.push(r);break}r|=128,i.push(r)}}function yt(i,e){if(!i)throw Error(e||"Assertion failed")}class hn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let r=new Map,n=a=>{let o=a.toBase58(),u=r.get(o);return u===void 0&&(u={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(o,u)),u},s=n(t);for(let a of(s.isSigner=!0,s.isWritable=!0,e))for(let o of(n(a.programId).isInvoked=!0,a.keys)){let u=n(o.pubkey);u.isSigner||=o.isSigner,u.isWritable||=o.isWritable}return new hn(t,r)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];yt(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,o])=>o.isSigner&&o.isWritable),r=e.filter(([,o])=>o.isSigner&&!o.isWritable),n=e.filter(([,o])=>!o.isSigner&&o.isWritable),s=e.filter(([,o])=>!o.isSigner&&!o.isWritable),a={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:s.length};{yt(t.length>0,"Expected at least one writable signer key");let[o]=t[0];yt(o===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[a,[...t.map(([o])=>new Ue(o)),...r.map(([o])=>new Ue(o)),...n.map(([o])=>new Ue(o)),...s.map(([o])=>new Ue(o))]]}extractTableLookup(e){let[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&a.isWritable),[n,s]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&!a.isWritable);if(t.length!==0||n.length!==0)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:s}]}drainKeysFoundInLookupTable(e,t){let r=[],n=[];for(let[s,a]of this.keyMetaMap.entries())if(t(a)){let o=new Ue(s),u=e.findIndex(b=>b.equals(o));u>=0&&(yt(u<256,"Max lookup table index exceeded"),r.push(u),n.push(o),this.keyMetaMap.delete(s))}return[r,n]}}let Vi="Reached end of buffer unexpectedly";function dr(i){if(i.length===0)throw Error(Vi);return i.shift()}function Xt(i,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw Error(Vi);return i.splice(...e)}class br{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new Ue(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Ct().decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new dn(this.staticAccountKeys)}static compile(e){let[t,r]=hn.compile(e.instructions,e.payerKey).getMessageComponents(),n=new dn(r).compileInstructions(e.instructions).map(s=>({programIdIndex:s.programIdIndex,accounts:s.accountKeyIndexes,data:Ct().encode(s.data)}));return new br({header:t,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:n})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(!(e>=this.header.numRequiredSignatures))return e<t-this.header.numReadonlySignedAccounts;{let r=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return e-t<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];Yt(t,e);let r=this.instructions.map(m=>{let{accounts:p,programIdIndex:S}=m,l=Array.from(Ct().decode(m.data)),h=[];Yt(h,p.length);let P=[];return Yt(P,l.length),{programIdIndex:S,keyIndicesCount:C.Buffer.from(h),keyIndices:p,dataLength:C.Buffer.from(P),data:l}}),n=[];Yt(n,r.length);let s=C.Buffer.alloc(1232);C.Buffer.from(n).copy(s);let a=n.length;r.forEach(m=>{let p=f.w3([f.u8("programIdIndex"),f.av(m.keyIndicesCount.length,"keyIndicesCount"),f.O6(f.u8("keyIndex"),m.keyIndices.length,"keyIndices"),f.av(m.dataLength.length,"dataLength"),f.O6(f.u8("userdatum"),m.data.length,"data")]).encode(m,s,a);a+=p}),s=s.slice(0,a);let o=f.w3([f.av(1,"numRequiredSignatures"),f.av(1,"numReadonlySignedAccounts"),f.av(1,"numReadonlyUnsignedAccounts"),f.av(t.length,"keyCount"),f.O6(et("key"),e,"keys"),et("recentBlockhash")]),u={numRequiredSignatures:C.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:C.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:C.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:C.Buffer.from(t),keys:this.accountKeys.map(m=>at(m.toBytes())),recentBlockhash:Ct().decode(this.recentBlockhash)},b=C.Buffer.alloc(2048),g=o.encode(u,b);return s.copy(b,g),b.slice(0,g+s.length)}static from(e){let t=[...e],r=dr(t);if(r!==(127&r))throw Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let n=dr(t),s=dr(t),a=Zt(t),o=[];for(let m=0;m<a;m++){let p=Xt(t,0,32);o.push(new Ue(C.Buffer.from(p)))}let u=Xt(t,0,32),b=Zt(t),g=[];for(let m=0;m<b;m++){let p=dr(t),S=Zt(t),l=Xt(t,0,S),h=Zt(t),P=Xt(t,0,h),W=Ct().encode(C.Buffer.from(P));g.push({programIdIndex:p,accounts:l,data:W})}return new br({header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:s},recentBlockhash:Ct().encode(C.Buffer.from(u)),accountKeys:o,instructions:g})}}class fn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw Error("Failed to get account keys because address table lookups were not resolved");return new dn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r)return e-r<this.addressTableLookups.reduce((n,s)=>n+s.writableIndexes.length,0);if(!(e>=this.header.numRequiredSignatures))return e<t-this.header.numReadonlySignedAccounts;{let n=r-t-this.header.numReadonlyUnsignedAccounts;return e-t<n}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let r of this.addressTableLookups){let n=e.find(s=>s.key.equals(r.accountKey));if(!n)throw Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(let s of r.writableIndexes)if(s<n.state.addresses.length)t.writable.push(n.state.addresses[s]);else throw Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`);for(let s of r.readonlyIndexes)if(s<n.state.addresses.length)t.readonly.push(n.state.addresses[s]);else throw Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){let t=hn.compile(e.instructions,e.payerKey),r=[],n={writable:[],readonly:[]};for(let u of e.addressLookupTableAccounts||[]){let b=t.extractTableLookup(u);if(b!==void 0){let[g,{writable:m,readonly:p}]=b;r.push(g),n.writable.push(...m),n.readonly.push(...p)}}let[s,a]=t.getMessageComponents(),o=new dn(a,n).compileInstructions(e.instructions);return new fn({header:s,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:o,addressTableLookups:r})}serialize(){let e=[];Yt(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),r=[];Yt(r,this.compiledInstructions.length);let n=this.serializeAddressTableLookups(),s=[];Yt(s,this.addressTableLookups.length);let a=f.w3([f.u8("prefix"),f.w3([f.u8("numRequiredSignatures"),f.u8("numReadonlySignedAccounts"),f.u8("numReadonlyUnsignedAccounts")],"header"),f.av(e.length,"staticAccountKeysLength"),f.O6(et(),this.staticAccountKeys.length,"staticAccountKeys"),et("recentBlockhash"),f.av(r.length,"instructionsLength"),f.av(t.length,"serializedInstructions"),f.av(s.length,"addressTableLookupsLength"),f.av(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(1232),u=a.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(b=>b.toBytes()),recentBlockhash:Ct().decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:n},o);return o.slice(0,u)}serializeInstructions(){let e=0,t=new Uint8Array(1232);for(let r of this.compiledInstructions){let n=[];Yt(n,r.accountKeyIndexes.length);let s=[];Yt(s,r.data.length);let a=f.w3([f.u8("programIdIndex"),f.av(n.length,"encodedAccountKeyIndexesLength"),f.O6(f.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),f.av(s.length,"encodedDataLength"),f.av(r.data.length,"data")]);e+=a.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(1232);for(let r of this.addressTableLookups){let n=[];Yt(n,r.writableIndexes.length);let s=[];Yt(s,r.readonlyIndexes.length);let a=f.w3([et("accountKey"),f.av(n.length,"encodedWritableIndexesLength"),f.O6(f.u8(),r.writableIndexes.length,"writableIndexes"),f.av(s.length,"encodedReadonlyIndexesLength"),f.O6(f.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=a.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],r=dr(t),n=127&r;yt(r!==n,"Expected versioned message but received legacy message"),yt(n===0,`Expected versioned message with version 0 but found version ${n}`);let s={numRequiredSignatures:dr(t),numReadonlySignedAccounts:dr(t),numReadonlyUnsignedAccounts:dr(t)},a=[],o=Zt(t);for(let S=0;S<o;S++)a.push(new Ue(Xt(t,0,32)));let u=Ct().encode(Xt(t,0,32)),b=Zt(t),g=[];for(let S=0;S<b;S++){let l=dr(t),h=Zt(t),P=Xt(t,0,h),W=Zt(t),Te=new Uint8Array(Xt(t,0,W));g.push({programIdIndex:l,accountKeyIndexes:P,data:Te})}let m=Zt(t),p=[];for(let S=0;S<m;S++){let l=new Ue(Xt(t,0,32)),h=Zt(t),P=Xt(t,0,h),W=Zt(t),Te=Xt(t,0,W);p.push({accountKey:l,writableIndexes:P,readonlyIndexes:Te})}return new fn({header:s,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:g,addressTableLookups:p})}}let wr=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({}),Zs=C.Buffer.alloc(64).fill(0);class kt{constructor(e){this.keys=void 0,this.programId=void 0,this.data=C.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ht{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{let{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new kt(t))}),this}compileMessage(){let e,t,r;if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw Error("Transaction fee payer required");for(let h=0;h<t.length;h++)if(t[h].programId===void 0)throw Error(`Transaction instruction index ${h} has undefined program id`);let n=[],s=[];t.forEach(h=>{h.keys.forEach(W=>{s.push({...W})});let P=h.programId.toString();n.includes(P)||n.push(P)}),n.forEach(h=>{s.push({pubkey:new Ue(h),isSigner:!1,isWritable:!1})});let a=[];s.forEach(h=>{let P=h.pubkey.toString(),W=a.findIndex(Te=>Te.pubkey.toString()===P);W>-1?(a[W].isWritable=a[W].isWritable||h.isWritable,a[W].isSigner=a[W].isSigner||h.isSigner):a.push(h)}),a.sort(function(h,P){return h.isSigner!==P.isSigner?h.isSigner?-1:1:h.isWritable!==P.isWritable?h.isWritable?-1:1:h.pubkey.toBase58().localeCompare(P.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})});let o=a.findIndex(h=>h.pubkey.equals(r));if(o>-1){let[h]=a.splice(o,1);h.isSigner=!0,h.isWritable=!0,a.unshift(h)}else a.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(let h of this.signatures){let P=a.findIndex(W=>W.pubkey.equals(h.publicKey));if(P>-1)a[P].isSigner||(a[P].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw Error(`unknown signer: ${h.publicKey.toString()}`)}let u=0,b=0,g=0,m=[],p=[];a.forEach(({pubkey:h,isSigner:P,isWritable:W})=>{P?(m.push(h.toString()),u+=1,W||(b+=1)):(p.push(h.toString()),W||(g+=1))});let S=m.concat(p),l=t.map(h=>{let{data:P,programId:W}=h;return{programIdIndex:S.indexOf(W.toString()),accounts:h.keys.map(Te=>S.indexOf(Te.pubkey.toString())),data:Ct().encode(P)}});return l.forEach(h=>{yt(h.programIdIndex>=0),h.accounts.forEach(P=>yt(P>=0))}),new br({header:{numRequiredSignatures:u,numReadonlySignedAccounts:b,numReadonlyUnsignedAccounts:g},accountKeys:S,recentBlockhash:e,instructions:l})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,n)=>t[n].equals(r.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw Error("No signers");let t=new Set;this.signatures=e.filter(r=>{let n=r.toString();return!t.has(n)&&(t.add(n),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw Error("No signers");let t=new Set,r=[];for(let s of e){let a=s.publicKey.toString();t.has(a)||(t.add(a),r.push(s))}this.signatures=r.map(s=>({signature:null,publicKey:s.publicKey}));let n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(e.length===0)throw Error("No signers");let t=new Set,r=[];for(let s of e){let a=s.publicKey.toString();t.has(a)||(t.add(a),r.push(s))}let n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){let r=e.serialize();t.forEach(n=>{let s=Ki(r,n.secretKey);this._addSignature(n.publicKey,at(s))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){yt(t.length===64);let r=this.signatures.findIndex(n=>e.equals(n.publicKey));if(r<0)throw Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=C.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let r={};for(let{signature:n,publicKey:s}of this.signatures)n===null?t&&(r.missing||=[]).push(s):$s(n,e,s.toBytes())||(r.invalid||=[]).push(s);return r.invalid||r.missing?r:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){let s=this._getMessageSignednessErrors(n,t);if(s){let a="Signature verification failed.";throw s.invalid&&(a+=`
Invalid signature for public key${s.invalid.length===1?"":"(s)"} [\`${s.invalid.map(o=>o.toBase58()).join("`, `")}\`].`),s.missing&&(a+=`
Missing signature for public key${s.missing.length===1?"":"(s)"} [\`${s.missing.map(o=>o.toBase58()).join("`, `")}\`].`),Error(a)}}return this._serialize(n)}_serialize(e){let{signatures:t}=this,r=[];Yt(r,t.length);let n=r.length+64*t.length+e.length,s=C.Buffer.alloc(n);return yt(t.length<256),C.Buffer.from(r).copy(s,0),t.forEach(({signature:a},o)=>{a!==null&&(yt(a.length===64,"signature has invalid length"),C.Buffer.from(a).copy(s,r.length+64*o))}),e.copy(s,r.length+64*t.length),yt(s.length<=1232,`Transaction too large: ${s.length} > 1232`),s}get keys(){return yt(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return yt(this.instructions.length===1),this.instructions[0].programId}get data(){return yt(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],r=Zt(t),n=[];for(let s=0;s<r;s++){let a=Xt(t,0,64);n.push(Ct().encode(C.Buffer.from(a)))}return ht.populate(br.from(t),n)}static populate(e,t=[]){let r=new ht;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((n,s)=>{let a={signature:n==Ct().encode(Zs)?null:Ct().decode(n),publicKey:e.accountKeys[s]};r.signatures.push(a)}),e.instructions.forEach(n=>{let s=n.accounts.map(a=>{let o=e.accountKeys[a];return{pubkey:o,isSigner:r.signatures.some(u=>u.publicKey.toString()===o.toString())||e.isAccountSigner(a),isWritable:e.isAccountWritable(a)}});r.instructions.push(new kt({keys:s,programId:e.accountKeys[n.programIdIndex],data:Ct().decode(n.data)}))}),r._message=e,r._json=r.toJSON(),r}}let hr=new Ue("SysvarC1ock11111111111111111111111111111111");new Ue("SysvarEpochSchedu1e111111111111111111111111"),new Ue("Sysvar1nstructions1111111111111111111111111");let Dn=new Ue("SysvarRecentB1ockHashes11111111111111111111"),Qr=new Ue("SysvarRent111111111111111111111111111111111");new Ue("SysvarRewards111111111111111111111111111111"),new Ue("SysvarS1otHashes111111111111111111111111111"),new Ue("SysvarS1otHistory11111111111111111111111111");let Hn=new Ue("SysvarStakeHistory1111111111111111111111111");class Kn extends Error{constructor({action:e,signature:t,transactionMessage:r,logs:n}){let s,a=n?`Logs: 
${JSON.stringify(n.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";switch(e){case"send":s=`Transaction ${t} resulted in an error. 
${r}. `+a+o;break;case"simulate":s=`Simulation failed. 
Message: ${r}. 
`+a+o;break;default:s=`Unknown action '${e}'`}super(s),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=r,this.transactionLogs=n||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(e==null||typeof e!="object"||!("then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,r)=>{e.getTransaction(this.signature).then(n=>{if(n&&n.meta&&n.meta.logMessages){let s=n.meta.logMessages;this.transactionLogs=s,t(s)}else r(Error("Log messages not found"))}).catch(r)})),await this.transactionLogs}}class Ae extends Error{constructor({code:e,message:t,data:r},n){super(n!=null?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}async function $i(i,e,t,r){let n,s=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},a=await i.sendTransaction(e,t,s);if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)n=(await i.confirmTransaction({abortSignal:r?.abortSignal,signature:a,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},r&&r.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){let{nonceInstruction:o}=e.nonceInfo,u=o.keys[0].pubkey;n=(await i.confirmTransaction({abortSignal:r?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:u,nonceValue:e.nonceInfo.nonce,signature:a},r&&r.commitment)).value}else r?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),n=(await i.confirmTransaction(a,r&&r.commitment)).value;if(n.err)throw a!=null?new Kn({action:"send",signature:a,transactionMessage:`Status: (${JSON.stringify(n)})`}):Error(`Transaction ${a} failed (${JSON.stringify(n)})`);return a}function _r(i){return new Promise(e=>setTimeout(e,i))}function ut(i,e){let t=i.layout.span>=0?i.layout.span:function s(a,o){let u=g=>{if(g.span>=0)return g.span;if(typeof g.alloc=="function")return g.alloc(o[g.property]);if("count"in g&&"elementLayout"in g){let m=o[g.property];if(Array.isArray(m))return m.length*u(g.elementLayout)}else if("fields"in g)return s({layout:g},o[g.property]);return 0},b=0;return a.layout.fields.forEach(g=>{b+=u(g)}),b}(i,e),r=C.Buffer.alloc(t),n=Object.assign({instruction:i.index},e);return i.layout.encode(n,r),r}let Ys=f.I0("lamportsPerSignature"),Gi=f.w3([f.DH("version"),f.DH("state"),et("authorizedPubkey"),et("nonce"),f.w3([Ys],"feeCalculator")]),Zi=Gi.span;class Fn{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){let t=Gi.decode(at(e),0);return new Fn({authorizedPubkey:new Ue(t.authorizedPubkey),nonce:new Ue(t.nonce).toString(),feeCalculator:t.feeCalculator})}}function Hr(i){let e=(0,f.av)(8,i),t=e.decode.bind(e),r=e.encode.bind(e),n=((s={})=>function(a,o){if(zr(a)!==zr(o))throw new Nr(8078004);if(zr(a)&&zr(o)&&a.fixedSize!==o.fixedSize)throw new Nr(8078005,{decoderFixedSize:o.fixedSize,encoderFixedSize:a.fixedSize});if(!zr(a)&&!zr(o)&&a.maxSize!==o.maxSize)throw new Nr(8078006,{decoderMaxSize:o.maxSize,encoderMaxSize:a.maxSize});return{...o,...a,decode:o.decode,encode:a.encode,read:o.read,write:a.write}}(Si(s),((a={})=>{var o,u;return Object.freeze({...u={fixedSize:(o={config:a,get:(b,g)=>b.getBigUint64(0,g),name:"u64",size:8}).size,read(b,g=0){(function(p,S,l=0){if(S.length-l<=0)throw new Nr(8078e3,{codecDescription:p})})(o.name,b,g),function(p,S,l,h=0){let P=l.length-h;if(P<S)throw new Nr(8078001,{bytesLength:P,codecDescription:p,expected:S})}(o.name,o.size,b,g);let m=new DataView(function(p,S,l){let h=p.byteOffset+(S??0),P=l??p.byteLength;return p.buffer.slice(h,h+P)}(b,g,o.size));return[o.get(m,vi(o.config)),g+o.size]}},decode:(b,g=0)=>u.read(b,g)[0]})})(s)))();return e.decode=(s,a)=>{let o=t(s,a);return n.decode(o)},e.encode=(s,a,o)=>r(n.encode(s),a,o),e}let Jt=Object.freeze({Create:{index:0,layout:f.w3([f.DH("instruction"),f.Wg("lamports"),f.Wg("space"),et("programId")])},Assign:{index:1,layout:f.w3([f.DH("instruction"),et("programId")])},Transfer:{index:2,layout:f.w3([f.DH("instruction"),Hr("lamports")])},CreateWithSeed:{index:3,layout:f.w3([f.DH("instruction"),et("base"),Dr("seed"),f.Wg("lamports"),f.Wg("space"),et("programId")])},AdvanceNonceAccount:{index:4,layout:f.w3([f.DH("instruction")])},WithdrawNonceAccount:{index:5,layout:f.w3([f.DH("instruction"),f.Wg("lamports")])},InitializeNonceAccount:{index:6,layout:f.w3([f.DH("instruction"),et("authorized")])},AuthorizeNonceAccount:{index:7,layout:f.w3([f.DH("instruction"),et("authorized")])},Allocate:{index:8,layout:f.w3([f.DH("instruction"),f.Wg("space")])},AllocateWithSeed:{index:9,layout:f.w3([f.DH("instruction"),et("base"),Dr("seed"),f.Wg("space"),et("programId")])},AssignWithSeed:{index:10,layout:f.w3([f.DH("instruction"),et("base"),Dr("seed"),et("programId")])},TransferWithSeed:{index:11,layout:f.w3([f.DH("instruction"),Hr("lamports"),Dr("seed"),et("programId")])},UpgradeNonceAccount:{index:12,layout:f.w3([f.DH("instruction")])}});class Nt{constructor(){}static createAccount(e){let t=ut(Jt.Create,{lamports:e.lamports,space:e.space,programId:at(e.programId.toBuffer())});return new kt({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;return"basePubkey"in e?(t=ut(Jt.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:at(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]):(t=ut(Jt.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]),new kt({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;return"basePubkey"in e?(t=ut(Jt.AssignWithSeed,{base:at(e.basePubkey.toBuffer()),seed:e.seed,programId:at(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]):(t=ut(Jt.Assign,{programId:at(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]),new kt({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=ut(Jt.CreateWithSeed,{base:at(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:at(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new kt({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){let t=new ht;"basePubkey"in e&&"seed"in e?t.add(Nt.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Zi,programId:this.programId})):t.add(Nt.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Zi,programId:this.programId}));let r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){let t=ut(Jt.InitializeNonceAccount,{authorized:at(e.authorizedPubkey.toBuffer())});return new kt({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1}],programId:this.programId,data:t})}static nonceAdvance(e){let t=ut(Jt.AdvanceNonceAccount);return new kt({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceWithdraw(e){let t=ut(Jt.WithdrawNonceAccount,{lamports:e.lamports});return new kt({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){let t=ut(Jt.AuthorizeNonceAccount,{authorized:at(e.newAuthorizedPubkey.toBuffer())});return new kt({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;return"basePubkey"in e?(t=ut(Jt.AllocateWithSeed,{base:at(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:at(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]):(t=ut(Jt.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]),new kt({keys:r,programId:this.programId,data:t})}}Nt.programId=new Ue("11111111111111111111111111111111");class pn{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/pn.chunkSize)+1+1)}static async load(e,t,r,n,s){{let m=await e.getMinimumBalanceForRentExemption(s.length),p=await e.getAccountInfo(r.publicKey,"confirmed"),S=null;if(p!==null){if(p.executable)return console.error("Program load failed, account is already executable"),!1;p.data.length!==s.length&&(S=S||new ht).add(Nt.allocate({accountPubkey:r.publicKey,space:s.length})),p.owner.equals(n)||(S=S||new ht).add(Nt.assign({accountPubkey:r.publicKey,programId:n})),p.lamports<m&&(S=S||new ht).add(Nt.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:m-p.lamports}))}else S=new ht().add(Nt.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:m>0?m:1,space:s.length,programId:n}));S!==null&&await $i(e,S,[t,r],{commitment:"confirmed"})}let a=f.w3([f.DH("instruction"),f.DH("offset"),f.DH("bytesLength"),f.DH("bytesLengthPadding"),f.O6(f.u8("byte"),f.cY(f.DH(),-8),"bytes")]),o=pn.chunkSize,u=0,b=s,g=[];for(;b.length>0;){let m=b.slice(0,o),p=C.Buffer.alloc(o+16);a.encode({instruction:0,offset:u,bytes:m,bytesLength:0,bytesLengthPadding:0},p);let S=new ht().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:p});g.push($i(e,S,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await _r(250),u+=o,b=b.slice(o)}await Promise.all(g);{let m=f.w3([f.DH("instruction")]),p=C.Buffer.alloc(m.span);m.encode({instruction:1},p);let S=new ht().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Qr,isSigner:!1,isWritable:!1}],programId:n,data:p}),l="processed",h=await e.sendTransaction(S,[t,r],{preflightCommitment:l}),{context:P,value:W}=await e.confirmTransaction({signature:h,lastValidBlockHeight:S.lastValidBlockHeight,blockhash:S.recentBlockhash},l);if(W.err)throw Error(`Transaction ${h} failed (${JSON.stringify(W)})`);for(;;){try{if(await e.getSlot({commitment:l})>P.slot)break}catch{}await new Promise(Te=>setTimeout(Te,Math.round(200)))}}return!0}}pn.chunkSize=932,new Ue("BPFLoader2111111111111111111111111111111111");var Yi=function(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}(function(){if(xe)return Oe;xe=1;var i=Object.prototype.toString,e=Object.keys||function(t){var r=[];for(var n in t)r.push(n);return r};return Oe=function(t){var r=function n(s,a){var o,u,b,g,m,p,S;if(s===!0)return"true";if(s===!1)return"false";switch(typeof s){case"object":if(s===null)return null;if(s.toJSON&&typeof s.toJSON=="function")return n(s.toJSON(),a);if((S=i.call(s))==="[object Array]"){for(o=0,b="[",u=s.length-1;o<u;o++)b+=n(s[o],!0)+",";return u>-1&&(b+=n(s[o],!0)),b+"]"}if(S!=="[object Object]")return JSON.stringify(s);for(u=(g=e(s).sort()).length,b="",o=0;o<u;)(p=n(s[m=g[o]],!1))!==void 0&&(b&&(b+=","),b+=JSON.stringify(m)+":"+p),o++;return"{"+b+"}";case"function":case"undefined":return a?null:void 0;case"string":return JSON.stringify(s);default:return isFinite(s)?s:null}}(t,!1);if(r!==void 0)return""+r}}());function jn(i){let e=0;for(;i>1;)i/=2,e++;return e}class Xs{constructor(e,t,r,n,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){var t;let r=jn((t=e+32+1)===0?1:(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,(t|=t>>32)+1))-jn(32)-1,n=this.getSlotsInEpoch(r);return[r,e-(n-32)]}{let r=e-this.firstNormalSlot,n=Math.floor(r/this.slotsPerEpoch);return[this.firstNormalEpoch+n,r%this.slotsPerEpoch]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*32:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+jn(32)):this.slotsPerEpoch}}var Js=on.fetch;class Qs extends zs{constructor(e,t,r){super(n=>{let s=new Ls(n,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in s?this.underlyingSocket=s.socket:this.underlyingSocket=s,s},e,t,r),this.underlyingSocket=void 0}call(...e){let t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){let t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}class Xi{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){let e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){let t=function(s,a){let o;try{o=s.layout.decode(a)}catch(u){throw Error("invalid instruction; "+u)}if(o.typeIndex!==s.index)throw Error(`invalid account data; account type mismatch ${o.typeIndex} != ${s.index}`);return o}(eo,e),r=e.length-56;yt(r>=0,"lookup table is invalid"),yt(r%32==0,"lookup table is invalid");let{addresses:n}=f.w3([f.O6(et(),r/32,"addresses")]).decode(e.slice(56));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new Ue(t.authority[0]):void 0,addresses:n.map(s=>new Ue(s))}}}let eo={index:1,layout:f.w3([f.DH("typeIndex"),Hr("deactivationSlot"),f.I0("lastExtendedSlot"),f.u8("lastExtendedStartIndex"),f.u8(),f.O6(et(),f.cY(f.u8(),-1),"authority")])},to=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i,Bt=Yr(Tn(Ue),Q(),i=>new Ue(i)),Ji=Cn([Q(),It("base64")]),Mn=Yr(Tn(C.Buffer),Ji,i=>C.Buffer.from(i[0],"base64"));function bt(i){let e,t;if(typeof i=="string")e=i;else if(i){let{commitment:r,...n}=i;e=r,t=n}return{commitment:e,config:t}}function Qi(i){return i.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function es(i){return Ht([D({jsonrpc:It("2.0"),id:Q(),result:i}),D({jsonrpc:It("2.0"),id:Q(),error:D({code:Ur(),message:Q(),data:Ne(Br("any",()=>!0))})})])}let ro=es(Ur());function Ze(i){return Yr(es(i),ro,e=>"error"in e?e:{...e,result:ne(e.result,i)})}function _t(i){return Ze(D({context:D({slot:I()}),value:i}))}function gn(i){return D({context:D({slot:I()}),value:i})}function Vn(i,e){return i===0?new fn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new Ue(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Ct().decode(t.data)})),addressTableLookups:e.addressTableLookups}):new br(e)}let no=D({foundation:I(),foundationTerm:I(),initial:I(),taper:I(),terminal:I()}),io=Ze(ce(ue(D({epoch:I(),effectiveSlot:I(),amount:I(),postBalance:I(),commission:Ne(ue(I()))})))),so=ce(D({slot:I(),prioritizationFee:I()})),oo=D({total:I(),validator:I(),foundation:I(),epoch:I()}),ao=D({epoch:I(),slotIndex:I(),slotsInEpoch:I(),absoluteSlot:I(),blockHeight:Ne(I()),transactionCount:Ne(I())}),co=D({slotsPerEpoch:I(),leaderScheduleSlotOffset:I(),warmup:rr(),firstNormalEpoch:I(),firstNormalSlot:I()}),uo=Ei(Q(),ce(I())),Pr=ue(Ht([D({}),Q()])),lo=D({err:Pr}),ho=It("receivedSignature"),fo=D({"solana-core":Q(),"feature-set":Ne(I())}),po=D({program:Q(),programId:Bt,parsed:Ur()}),go=D({programId:Bt,accounts:ce(Bt),data:Q()}),ts=_t(D({err:ue(Ht([D({}),Q()])),logs:ue(ce(Q())),accounts:Ne(ue(ce(ue(D({executable:rr(),owner:Q(),lamports:I(),data:ce(Q()),rentEpoch:Ne(I())}))))),unitsConsumed:Ne(I()),returnData:Ne(ue(D({programId:Q(),data:Cn([Q(),It("base64")])}))),innerInstructions:Ne(ue(ce(D({index:I(),instructions:ce(Ht([po,go]))}))))})),mo=_t(D({byIdentity:Ei(Q(),ce(I())),range:D({firstSlot:I(),lastSlot:I()})})),yo=Ze(no),bo=Ze(oo),wo=Ze(so),ko=Ze(ao),vo=Ze(co),So=Ze(uo),xo=Ze(I()),Eo=_t(D({total:I(),circulating:I(),nonCirculating:I(),nonCirculatingAccounts:ce(Bt)})),$n=D({amount:Q(),uiAmount:ue(I()),decimals:I(),uiAmountString:Ne(Q())}),Io=_t(ce(D({address:Bt,amount:Q(),uiAmount:ue(I()),decimals:I(),uiAmountString:Ne(Q())}))),Bo=_t(ce(D({pubkey:Bt,account:D({executable:rr(),owner:Bt,lamports:I(),data:Mn,rentEpoch:I()})}))),Gn=D({program:Q(),parsed:Ur(),space:I()}),Ao=_t(ce(D({pubkey:Bt,account:D({executable:rr(),owner:Bt,lamports:I(),data:Gn,rentEpoch:I()})}))),_o=_t(ce(D({lamports:I(),address:Bt}))),en=D({executable:rr(),owner:Bt,lamports:I(),data:Mn,rentEpoch:I()}),Po=D({pubkey:Bt,account:en}),Oo=Yr(Ht([Tn(C.Buffer),Gn]),Ht([Ji,Gn]),i=>Array.isArray(i)?ne(i,Mn):i),Zn=D({executable:rr(),owner:Bt,lamports:I(),data:Oo,rentEpoch:I()}),To=D({pubkey:Bt,account:Zn}),Co=D({state:Ht([It("active"),It("inactive"),It("activating"),It("deactivating")]),active:I(),inactive:I()}),Ro=Ze(ce(D({signature:Q(),slot:I(),err:Pr,memo:ue(Q()),blockTime:Ne(ue(I()))}))),Lo=Ze(ce(D({signature:Q(),slot:I(),err:Pr,memo:ue(Q()),blockTime:Ne(ue(I()))}))),No=D({subscription:I(),result:gn(en)}),zo=D({pubkey:Bt,account:en}),Wo=D({subscription:I(),result:gn(zo)}),Uo=D({parent:I(),slot:I(),root:I()}),qo=D({subscription:I(),result:Uo}),Do=Ht([D({type:Ht([It("firstShredReceived"),It("completed"),It("optimisticConfirmation"),It("root")]),slot:I(),timestamp:I()}),D({type:It("createdBank"),parent:I(),slot:I(),timestamp:I()}),D({type:It("frozen"),slot:I(),timestamp:I(),stats:D({numTransactionEntries:I(),numSuccessfulTransactions:I(),numFailedTransactions:I(),maxTransactionsPerEntry:I()})}),D({type:It("dead"),slot:I(),timestamp:I(),err:Q()})]),Ho=D({subscription:I(),result:Do}),Ko=D({subscription:I(),result:gn(Ht([lo,ho]))}),Fo=D({subscription:I(),result:I()}),jo=D({pubkey:Q(),gossip:ue(Q()),tpu:ue(Q()),rpc:ue(Q()),version:ue(Q())}),rs=D({votePubkey:Q(),nodePubkey:Q(),activatedStake:I(),epochVoteAccount:rr(),epochCredits:ce(Cn([I(),I(),I()])),commission:I(),lastVote:I(),rootSlot:ue(I())}),Mo=Ze(D({current:ce(rs),delinquent:ce(rs)})),Vo=Ht([It("processed"),It("confirmed"),It("finalized")]),$o=D({slot:I(),confirmations:ue(I()),err:Pr,confirmationStatus:Ne(Vo)}),Go=_t(ce(ue($o))),Zo=Ze(I()),ns=D({accountKey:Bt,writableIndexes:ce(I()),readonlyIndexes:ce(I())}),Yn=D({signatures:ce(Q()),message:D({accountKeys:ce(Q()),header:D({numRequiredSignatures:I(),numReadonlySignedAccounts:I(),numReadonlyUnsignedAccounts:I()}),instructions:ce(D({accounts:ce(I()),data:Q(),programIdIndex:I()})),recentBlockhash:Q(),addressTableLookups:Ne(ce(ns))})}),is=D({pubkey:Bt,signer:rr(),writable:rr(),source:Ne(Ht([It("transaction"),It("lookupTable")]))}),ss=D({accountKeys:ce(is),signatures:ce(Q())}),os=D({parsed:Ur(),program:Q(),programId:Bt}),as=D({accounts:ce(Bt),data:Q(),programId:Bt}),cs=Yr(Ht([as,os]),Ht([D({parsed:Ur(),program:Q(),programId:Q()}),D({accounts:ce(Q()),data:Q(),programId:Q()})]),i=>"accounts"in i?ne(i,as):ne(i,os)),us=D({signatures:ce(Q()),message:D({accountKeys:ce(is),instructions:ce(cs),recentBlockhash:Q(),addressTableLookups:Ne(ue(ce(ns)))})}),mn=D({accountIndex:I(),mint:Q(),owner:Ne(Q()),programId:Ne(Q()),uiTokenAmount:$n}),ls=D({writable:ce(Bt),readonly:ce(Bt)}),yn=D({err:Pr,fee:I(),innerInstructions:Ne(ue(ce(D({index:I(),instructions:ce(D({accounts:ce(I()),data:Q(),programIdIndex:I()}))})))),preBalances:ce(I()),postBalances:ce(I()),logMessages:Ne(ue(ce(Q()))),preTokenBalances:Ne(ue(ce(mn))),postTokenBalances:Ne(ue(ce(mn))),loadedAddresses:Ne(ls),computeUnitsConsumed:Ne(I()),costUnits:Ne(I())}),Xn=D({err:Pr,fee:I(),innerInstructions:Ne(ue(ce(D({index:I(),instructions:ce(cs)})))),preBalances:ce(I()),postBalances:ce(I()),logMessages:Ne(ue(ce(Q()))),preTokenBalances:Ne(ue(ce(mn))),postTokenBalances:Ne(ue(ce(mn))),loadedAddresses:Ne(ls),computeUnitsConsumed:Ne(I()),costUnits:Ne(I())}),Kr=Ht([It(0),It("legacy")]),Or=D({pubkey:Q(),lamports:I(),postBalance:ue(I()),rewardType:ue(Q()),commission:Ne(ue(I()))}),Yo=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),transactions:ce(D({transaction:Yn,meta:ue(yn),version:Ne(Kr)})),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),Xo=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),Jo=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),transactions:ce(D({transaction:ss,meta:ue(yn),version:Ne(Kr)})),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),Qo=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),transactions:ce(D({transaction:us,meta:ue(Xn),version:Ne(Kr)})),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),ea=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),transactions:ce(D({transaction:ss,meta:ue(Xn),version:Ne(Kr)})),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),ta=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),rewards:Ne(ce(Or)),blockTime:ue(I()),blockHeight:ue(I())}))),ra=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),transactions:ce(D({transaction:Yn,meta:ue(yn)})),rewards:Ne(ce(Or)),blockTime:ue(I())}))),ds=Ze(ue(D({blockhash:Q(),previousBlockhash:Q(),parentSlot:I(),signatures:ce(Q()),blockTime:ue(I())}))),Jn=Ze(ue(D({slot:I(),meta:ue(yn),blockTime:Ne(ue(I())),transaction:Yn,version:Ne(Kr)}))),bn=Ze(ue(D({slot:I(),transaction:us,meta:ue(Xn),blockTime:Ne(ue(I())),version:Ne(Kr)}))),na=_t(D({blockhash:Q(),lastValidBlockHeight:I()})),ia=_t(rr()),sa=Ze(ce(D({slot:I(),numTransactions:I(),numSlots:I(),samplePeriodSecs:I()}))),oa=_t(ue(D({feeCalculator:D({lamportsPerSignature:I()})}))),aa=Ze(Q()),ca=Ze(Q()),ua=D({err:Pr,logs:ce(Q()),signature:Q()}),la=D({result:gn(ua),subscription:I()}),da={"solana-client":"js/1.0.0-maintenance"};class ha{constructor(e,t){var r;let n,s,a,o,u,b;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let g={};return async m=>{let{commitment:p,config:S}=bt(m),l=this._buildArgs([],p,void 0,S),h=Yi(l);return g[h]=g[h]??(async()=>{try{let P=await this._rpcRequest("getBlockHeight",l),W=ne(P,Ze(I()));if("error"in W)throw new Ae(W.error,"failed to get block height information");return W.result}finally{delete g[h]}})(),await g[h]}})(),t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,a=t.fetch,o=t.fetchMiddleware,u=t.disableRetryOnRateLimit,b=t.httpAgent),this._rpcEndpoint=function(g){if(/^https?:/.test(g)===!1)throw TypeError("Endpoint URL must start with `http:` or `https:`.");return g}(e),this._rpcWsEndpoint=n||function(g){let m=g.match(to);if(m==null)throw TypeError(`Failed to validate endpoint URL \`${g}\``);let[p,S,l,h]=m,P=g.startsWith("https:")?"wss:":"ws:",W=l==null?null:parseInt(l.slice(1),10),Te=W==null?"":`:${W+1}`;return`${P}//${S}${Te}${h}`}(e),this._rpcClient=function(g,m,p,S,l,h){let P,W,Te=p||Js;return h!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),S&&(W=async(ye,qe)=>{let ve=await new Promise((De,Re)=>{try{S(ye,qe,(Z,fe)=>De([Z,fe]))}catch(Z){Re(Z)}});return await Te(...ve)}),new(Rs())(async(ye,qe)=>{let ve={method:"POST",body:ye,agent:P,headers:Object.assign({"Content-Type":"application/json"},m||{},da)};try{let De,Re=5,Z=500;for(;De=W?await W(g,ve):await Te(g,ve),De.status===429&&l!==!0&&(Re-=1,Re!==0);)console.error(`Server responded with ${De.status} ${De.statusText}.  Retrying after ${Z}ms delay...`),await _r(Z),Z*=2;let fe=await De.text();De.ok?qe(null,fe):qe(Error(`${De.status} ${De.statusText}: ${fe}`))}catch(De){De instanceof Error&&qe(De)}},{})}(e,s,a,o,u,b),this._rpcRequest=(r=this._rpcClient,(g,m)=>new Promise((p,S)=>{r.request(g,m,(l,h)=>{if(l)return void S(l);p(h)})})),this._rpcBatchRequest=function(g){return m=>new Promise((p,S)=>{m.length===0&&p([]);let l=m.map(h=>g.request(h.methodName,h.args));g.request(l,(h,P)=>{if(h)return void S(h);p(P)})})}(this._rpcClient),this._rpcWebSocket=new Qs(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgs([e.toBase58()],r,void 0,n),a=ne(await this._rpcRequest("getBalance",s),_t(I()));if("error"in a)throw new Ae(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){let t=ne(await this._rpcRequest("getBlockTime",[e]),Ze(ue(I())));if("error"in t)throw new Ae(t.error,`failed to get block time for slot ${e}`);return t.result}async getMinimumLedgerSlot(){let e=ne(await this._rpcRequest("minimumLedgerSlot",[]),Ze(I()));if("error"in e)throw new Ae(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){let e=ne(await this._rpcRequest("getFirstAvailableBlock",[]),xo);if("error"in e)throw new Ae(e.error,"failed to get first available block");return e.result}async getSupply(e){let t={};t=typeof e=="string"?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};let r=ne(await this._rpcRequest("getSupply",[t]),Eo);if("error"in r)throw new Ae(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){let r=this._buildArgs([e.toBase58()],t),n=ne(await this._rpcRequest("getTokenSupply",r),_t($n));if("error"in n)throw new Ae(n.error,"failed to get token supply");return n.result}async getTokenAccountBalance(e,t){let r=this._buildArgs([e.toBase58()],t),n=ne(await this._rpcRequest("getTokenAccountBalance",r),_t($n));if("error"in n)throw new Ae(n.error,"failed to get token account balance");return n.result}async getTokenAccountsByOwner(e,t,r){let{commitment:n,config:s}=bt(r),a=[e.toBase58()];"mint"in t?a.push({mint:t.mint.toBase58()}):a.push({programId:t.programId.toBase58()});let o=this._buildArgs(a,n,"base64",s),u=ne(await this._rpcRequest("getTokenAccountsByOwner",o),Bo);if("error"in u)throw new Ae(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});let s=this._buildArgs(n,r,"jsonParsed"),a=ne(await this._rpcRequest("getTokenAccountsByOwner",s),Ao);if("error"in a)throw new Ae(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){let t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=ne(await this._rpcRequest("getLargestAccounts",r),_o);if("error"in n)throw new Ae(n.error,"failed to get largest accounts");return n.result}async getTokenLargestAccounts(e,t){let r=this._buildArgs([e.toBase58()],t),n=ne(await this._rpcRequest("getTokenLargestAccounts",r),Io);if("error"in n)throw new Ae(n.error,"failed to get token largest accounts");return n.result}async getAccountInfoAndContext(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgs([e.toBase58()],r,"base64",n),a=ne(await this._rpcRequest("getAccountInfo",s),_t(ue(en)));if("error"in a)throw new Ae(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgs([e.toBase58()],r,"jsonParsed",n),a=ne(await this._rpcRequest("getAccountInfo",s),_t(ue(Zn)));if("error"in a)throw new Ae(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){let{commitment:r,config:n}=bt(t),s=e.map(u=>u.toBase58()),a=this._buildArgs([s],r,"jsonParsed",n),o=ne(await this._rpcRequest("getMultipleAccounts",a),_t(ce(ue(Zn))));if("error"in o)throw new Ae(o.error,`failed to get info for accounts ${s}`);return o.result}async getMultipleAccountsInfoAndContext(e,t){let{commitment:r,config:n}=bt(t),s=e.map(u=>u.toBase58()),a=this._buildArgs([s],r,"base64",n),o=ne(await this._rpcRequest("getMultipleAccounts",a),_t(ce(ue(en))));if("error"in o)throw new Ae(o.error,`failed to get info for accounts ${s}`);return o.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){let{commitment:n,config:s}=bt(t),a=this._buildArgs([e.toBase58()],n,void 0,{...s,epoch:r??s?.epoch}),o=ne(await this._rpcRequest("getStakeActivation",a),Ze(Co));if("error"in o)throw new Ae(o.error,`failed to get Stake Activation ${e.toBase58()}`);return o.result}async getProgramAccounts(e,t){let{commitment:r,config:n}=bt(t),{encoding:s,...a}=n||{},o=this._buildArgs([e.toBase58()],r,s||"base64",{...a,...a.filters?{filters:Qi(a.filters)}:null}),u=await this._rpcRequest("getProgramAccounts",o),b=ce(Po),g=a.withContext===!0?ne(u,_t(b)):ne(u,Ze(b));if("error"in g)throw new Ae(g.error,`failed to get accounts owned by program ${e.toBase58()}`);return g.result}async getParsedProgramAccounts(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgs([e.toBase58()],r,"jsonParsed",n),a=ne(await this._rpcRequest("getProgramAccounts",s),Ze(ce(To)));if("error"in a)throw new Ae(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let r,n;if(typeof e=="string")r=e;else{if(e.abortSignal?.aborted)return Promise.reject(e.abortSignal.reason);r=e.signature}try{n=Ct().decode(r)}catch{throw Error("signature must be base58 encoded: "+r)}return yt(n.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,s=!1;return{abortConfirmation:()=>{n&&(n(),n=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:new Promise((a,o)=>{try{r=this.onSignature(t,(b,g)=>{r=void 0,a({__type:wr.PROCESSED,response:{context:g,value:b}})},e);let u=new Promise(b=>{r==null?b():n=this._onSubscriptionStateChange(r,g=>{g==="subscribed"&&b()})});(async()=>{if(await u,s)return;let b=await this.getSignatureStatus(t);if(s||b==null)return;let{context:g,value:m}=b;if(m!=null)if(m?.err)o(m.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if(m.confirmationStatus==="processed")return;break;case"finalized":case"max":case"root":if(m.confirmationStatus==="processed"||m.confirmationStatus==="confirmed")return}s=!0,a({__type:wr.PROCESSED,response:{context:g,value:m}})}})()}catch(u){o(u)}})}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let s,a=!1,o=new Promise(m=>{let p=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let S=await p();if(!a){for(;S<=r;)if(await _r(1e3),a||(S=await p(),a))return;m({__type:wr.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:u,confirmationPromise:b}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),g=this.getCancellationPromise(t);try{let m=await Promise.race([g,b,o]);if(m.__type===wr.PROCESSED)s=m.response;else throw new ji(n)}finally{a=!0,u()}return s}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:s,signature:a}}){let o,u=!1,b=new Promise(S=>{let l=s,h=null,P=async()=>{try{let{context:W,value:Te}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return h=W.slot,Te?.nonce}catch{return l}};(async()=>{if(l=await P(),!u)for(;;){if(s!==l)return void S({__type:wr.NONCE_INVALID,slotInWhichNonceDidAdvance:h});if(await _r(2e3),u||(l=await P(),u))return}})()}),{abortConfirmation:g,confirmationPromise:m}=this.getTransactionConfirmationPromise({commitment:e,signature:a}),p=this.getCancellationPromise(t);try{let S=await Promise.race([p,m,b]);if(S.__type===wr.PROCESSED)o=S.response;else{let l;for(;;){let h=await this.getSignatureStatus(a);if(h==null)break;if(h.context.slot<(S.slotInWhichNonceDidAdvance??r)){await _r(400);continue}l=h;break}if(l?.value){let h=e||"finalized",{confirmationStatus:P}=l.value;switch(h){case"processed":case"recent":if(P!=="processed"&&P!=="confirmed"&&P!=="finalized")throw new Jr(a);break;case"confirmed":case"single":case"singleGossip":if(P!=="confirmed"&&P!=="finalized")throw new Jr(a);break;case"finalized":case"max":case"root":if(P!=="finalized")throw new Jr(a)}o={context:l.context,value:{err:l.value.err}}}else throw new Jr(a)}}finally{u=!0,g()}return o}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r,n,s=new Promise(u=>{let b=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":b=this._confirmTransactionInitialTimeout||3e4}r=setTimeout(()=>u({__type:wr.TIMED_OUT,timeoutMs:b}),b)}),{abortConfirmation:a,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});try{let u=await Promise.race([o,s]);if(u.__type===wr.PROCESSED)n=u.response;else throw new Mi(t,u.timeoutMs/1e3)}finally{clearTimeout(r),a()}return n}async getClusterNodes(){let e=ne(await this._rpcRequest("getClusterNodes",[]),Ze(ce(jo)));if("error"in e)throw new Ae(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(e){let t=this._buildArgs([],e),r=ne(await this._rpcRequest("getVoteAccounts",t),Mo);if("error"in r)throw new Ae(r.error,"failed to get vote accounts");return r.result}async getSlot(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,void 0,r),s=ne(await this._rpcRequest("getSlot",n),Ze(I()));if("error"in s)throw new Ae(s.error,"failed to get slot");return s.result}async getSlotLeader(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,void 0,r),s=ne(await this._rpcRequest("getSlotLeader",n),Ze(Q()));if("error"in s)throw new Ae(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(e,t){let r=ne(await this._rpcRequest("getSlotLeaders",[e,t]),Ze(ce(Bt)));if("error"in r)throw new Ae(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(e,t){let{context:r,value:n}=await this.getSignatureStatuses([e],t);return yt(n.length===1),{context:r,value:n[0]}}async getSignatureStatuses(e,t){let r=[e];t&&r.push(t);let n=ne(await this._rpcRequest("getSignatureStatuses",r),Go);if("error"in n)throw new Ae(n.error,"failed to get signature status");return n.result}async getTransactionCount(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,void 0,r),s=ne(await this._rpcRequest("getTransactionCount",n),Ze(I()));if("error"in s)throw new Ae(s.error,"failed to get transaction count");return s.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){let t=this._buildArgs([],e),r=ne(await this._rpcRequest("getInflationGovernor",t),yo);if("error"in r)throw new Ae(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,r){let{commitment:n,config:s}=bt(r),a=this._buildArgs([e.map(u=>u.toBase58())],n,void 0,{...s,epoch:t??s?.epoch}),o=ne(await this._rpcRequest("getInflationReward",a),io);if("error"in o)throw new Ae(o.error,"failed to get inflation reward");return o.result}async getInflationRate(){let e=ne(await this._rpcRequest("getInflationRate",[]),bo);if("error"in e)throw new Ae(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,void 0,r),s=ne(await this._rpcRequest("getEpochInfo",n),ko);if("error"in s)throw new Ae(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){let e=ne(await this._rpcRequest("getEpochSchedule",[]),vo);if("error"in e)throw new Ae(e.error,"failed to get epoch schedule");let t=e.result;return new Xs(t.slotsPerEpoch,t.leaderScheduleSlotOffset,t.warmup,t.firstNormalEpoch,t.firstNormalSlot)}async getLeaderSchedule(){let e=ne(await this._rpcRequest("getLeaderSchedule",[]),So);if("error"in e)throw new Ae(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(e,t){let r=this._buildArgs([e],t),n=ne(await this._rpcRequest("getMinimumBalanceForRentExemption",r),Zo);return"error"in n?(console.warn("Unable to fetch minimum balance for rent exemption"),0):n.result}async getRecentBlockhashAndContext(e){let{context:t,value:{blockhash:r}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:r,feeCalculator:{get lamportsPerSignature(){throw Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON:()=>({})}}}}async getRecentPerformanceSamples(e){let t=ne(await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),sa);if("error"in t)throw new Ae(t.error,"failed to get recent performance samples");return t.result}async getFeeCalculatorForBlockhash(e,t){let r=this._buildArgs([e],t),n=ne(await this._rpcRequest("getFeeCalculatorForBlockhash",r),oa);if("error"in n)throw new Ae(n.error,"failed to get fee calculator");let{context:s,value:a}=n.result;return{context:s,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){let r=at(e.serialize()).toString("base64"),n=this._buildArgs([r],t),s=ne(await this._rpcRequest("getFeeForMessage",n),_t(ue(I())));if("error"in s)throw new Ae(s.error,"failed to get fee for message");if(s.result===null)throw Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(e){let t=e?.lockedWritableAccounts?.map(s=>s.toBase58()),r=t?.length?[t]:[],n=ne(await this._rpcRequest("getRecentPrioritizationFees",r),wo);if("error"in n)throw new Ae(n.error,"failed to get recent prioritization fees");return n.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,void 0,r),s=ne(await this._rpcRequest("getLatestBlockhash",n),na);if("error"in s)throw new Ae(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgs([e],r,void 0,n),a=ne(await this._rpcRequest("isBlockhashValid",s),ia);if("error"in a)throw new Ae(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){let e=ne(await this._rpcRequest("getVersion",[]),Ze(fo));if("error"in e)throw new Ae(e.error,"failed to get version");return e.result}async getGenesisHash(){let e=ne(await this._rpcRequest("getGenesisHash",[]),Ze(Q()));if("error"in e)throw new Ae(e.error,"failed to get genesis hash");return e.result}async getBlock(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgsAtLeastConfirmed([e],r,void 0,n),a=await this._rpcRequest("getBlock",s);try{switch(n?.transactionDetails){case"accounts":{let o=ne(a,Jo);if("error"in o)throw o.error;return o.result}case"none":{let o=ne(a,Xo);if("error"in o)throw o.error;return o.result}default:{let o=ne(a,Yo);if("error"in o)throw o.error;let{result:u}=o;return u?{...u,transactions:u.transactions.map(({transaction:b,meta:g,version:m})=>({meta:g,transaction:{...b,message:Vn(m,b.message)},version:m}))}:null}}}catch(o){throw new Ae(o,"failed to get confirmed block")}}async getParsedBlock(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),a=await this._rpcRequest("getBlock",s);try{switch(n?.transactionDetails){case"accounts":{let o=ne(a,ea);if("error"in o)throw o.error;return o.result}case"none":{let o=ne(a,ta);if("error"in o)throw o.error;return o.result}default:{let o=ne(a,Qo);if("error"in o)throw o.error;return o.result}}}catch(o){throw new Ae(o,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){let{commitment:a,...o}=e;r=a,t=o}let n=this._buildArgs([],r,"base64",t),s=ne(await this._rpcRequest("getBlockProduction",n),mo);if("error"in s)throw new Ae(s.error,"failed to get block production information");return s.result}async getTransaction(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgsAtLeastConfirmed([e],r,void 0,n),a=ne(await this._rpcRequest("getTransaction",s),Jn);if("error"in a)throw new Ae(a.error,"failed to get transaction");let o=a.result;return o&&{...o,transaction:{...o.transaction,message:Vn(o.version,o.transaction.message)}}}async getParsedTransaction(e,t){let{commitment:r,config:n}=bt(t),s=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),a=ne(await this._rpcRequest("getTransaction",s),bn);if("error"in a)throw new Ae(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){let{commitment:r,config:n}=bt(t),s=e.map(a=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([a],r,"jsonParsed",n)}));return(await this._rpcBatchRequest(s)).map(a=>{let o=ne(a,bn);if("error"in o)throw new Ae(o.error,"failed to get transactions");return o.result})}async getTransactions(e,t){let{commitment:r,config:n}=bt(t),s=e.map(a=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([a],r,void 0,n)}));return(await this._rpcBatchRequest(s)).map(a=>{let o=ne(a,Jn);if("error"in o)throw new Ae(o.error,"failed to get transactions");let u=o.result;return u&&{...u,transaction:{...u.transaction,message:Vn(u.version,u.transaction.message)}}})}async getConfirmedBlock(e,t){let r=this._buildArgsAtLeastConfirmed([e],t),n=ne(await this._rpcRequest("getBlock",r),ra);if("error"in n)throw new Ae(n.error,"failed to get confirmed block");let s=n.result;if(!s)throw Error("Confirmed block "+e+" not found");let a={...s,transactions:s.transactions.map(({transaction:o,meta:u})=>{let b=new br(o.message);return{meta:u,transaction:{...o,message:b}}})};return{...a,transactions:a.transactions.map(({transaction:o,meta:u})=>({meta:u,transaction:ht.populate(o.message,o.signatures)}))}}async getBlocks(e,t,r){let n=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),s=ne(await this._rpcRequest("getBlocks",n),Ze(ce(I())));if("error"in s)throw new Ae(s.error,"failed to get blocks");return s.result}async getBlockSignatures(e,t){let r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=ne(await this._rpcRequest("getBlock",r),ds);if("error"in n)throw new Ae(n.error,"failed to get block");let s=n.result;if(!s)throw Error("Block "+e+" not found");return s}async getConfirmedBlockSignatures(e,t){let r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=ne(await this._rpcRequest("getBlock",r),ds);if("error"in n)throw new Ae(n.error,"failed to get confirmed block");let s=n.result;if(!s)throw Error("Confirmed block "+e+" not found");return s}async getConfirmedTransaction(e,t){let r=this._buildArgsAtLeastConfirmed([e],t),n=ne(await this._rpcRequest("getTransaction",r),Jn);if("error"in n)throw new Ae(n.error,"failed to get transaction");let s=n.result;if(!s)return s;let a=new br(s.transaction.message),o=s.transaction.signatures;return{...s,transaction:ht.populate(a,o)}}async getParsedConfirmedTransaction(e,t){let r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=ne(await this._rpcRequest("getTransaction",r),bn);if("error"in n)throw new Ae(n.error,"failed to get confirmed transaction");return n.result}async getParsedConfirmedTransactions(e,t){let r=e.map(n=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([n],t,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(n=>{let s=ne(n,bn);if("error"in s)throw new Ae(s.error,"failed to get confirmed transactions");return s.result})}async getConfirmedSignaturesForAddress(e,t,r){let n={},s=await this.getFirstAvailableBlock();for(;!("until"in n)&&!(--t<=0)&&!(t<s);)try{let o=await this.getConfirmedBlockSignatures(t,"finalized");o.signatures.length>0&&(n.until=o.signatures[o.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}let a=await this.getSlot("finalized");for(;!("before"in n)&&!(++r>a);)try{let o=await this.getConfirmedBlockSignatures(r);o.signatures.length>0&&(n.before=o.signatures[o.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}return(await this.getConfirmedSignaturesForAddress2(e,n)).map(o=>o.signature)}async getConfirmedSignaturesForAddress2(e,t,r){let n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=ne(await this._rpcRequest("getConfirmedSignaturesForAddress2",n),Ro);if("error"in s)throw new Ae(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(e,t,r){let n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=ne(await this._rpcRequest("getSignaturesForAddress",n),Lo);if("error"in s)throw new Ae(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(e,t){let{context:r,value:n}=await this.getAccountInfoAndContext(e,t),s=null;return n!==null&&(s=new Xi({key:e,state:Xi.deserialize(n.data)})),{context:r,value:s}}async getNonceAndContext(e,t){let{context:r,value:n}=await this.getAccountInfoAndContext(e,t),s=null;return n!==null&&(s=Fn.fromAccountData(n.data)),{context:r,value:s}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){let r=ne(await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),aa);if("error"in r)throw new Ae(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await _r(100);let t=Date.now()-this._blockhashInfo.lastFetch;if(this._blockhashInfo.latestBlockhash!==null&&!(t>=3e4))return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{let e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){let s=await this.getLatestBlockhash("finalized");if(r!==s.blockhash)return this._blockhashInfo={latestBlockhash:s,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},s;await _r(200)}throw Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){let{commitment:t,config:r}=bt(e),n=this._buildArgs([],t,"base64",r),s=ne(await this._rpcRequest("getStakeMinimumDelegation",n),_t(I()));if("error"in s)throw new Ae(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(e,t,r){let n;if("message"in e){let m=e.serialize(),p=C.Buffer.from(m).toString("base64");if(Array.isArray(t)||r!==void 0)throw Error("Invalid arguments");let S=t||{};S.encoding="base64","commitment"in S||(S.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(S.innerInstructions=t.innerInstructions);let l=[p,S],h=ne(await this._rpcRequest("simulateTransaction",l),ts);if("error"in h)throw Error("failed to simulate transaction: "+h.error.message);return h.result}if(e instanceof ht?((n=new ht).feePayer=e.feePayer,n.instructions=e.instructions,n.nonceInfo=e.nonceInfo,n.signatures=e.signatures):(n=ht.populate(e))._message=n._json=void 0,t!==void 0&&!Array.isArray(t))throw Error("Invalid arguments");if(n.nonceInfo&&t)n.sign(...t);else{let m=this._disableBlockhashCaching;for(;;){let p=await this._blockhashWithExpiryBlockHeight(m);if(n.lastValidBlockHeight=p.lastValidBlockHeight,n.recentBlockhash=p.blockhash,!t)break;if(n.sign(...t),!n.signature)throw Error("!signature");let S=n.signature.toString("base64");if(this._blockhashInfo.simulatedSignatures.includes(S)||this._blockhashInfo.transactionSignatures.includes(S))m=!0;else{this._blockhashInfo.simulatedSignatures.push(S);break}}}let s=n._compile(),a=s.serialize(),o=n._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};r&&(u.accounts={encoding:"base64",addresses:(Array.isArray(r)?r:s.nonProgramIds()).map(m=>m.toBase58())}),t&&(u.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(u.innerInstructions=t.innerInstructions);let b=[o,u],g=ne(await this._rpcRequest("simulateTransaction",b),ts);if("error"in g){let m;if("data"in g.error&&(m=g.error.data.logs)&&Array.isArray(m)){let p=`
    `,S=p+m.join(p);console.error(g.error.message,S)}throw new Kn({action:"simulate",signature:"",transactionMessage:g.error.message,logs:m})}return g.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw Error("Invalid arguments");let s=e.serialize();return await this.sendRawTransaction(s,t)}if(t===void 0||!Array.isArray(t))throw Error("Invalid arguments");if(e.nonceInfo)e.sign(...t);else{let s=this._disableBlockhashCaching;for(;;){let a=await this._blockhashWithExpiryBlockHeight(s);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...t),!e.signature)throw Error("!signature");let o=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(o))s=!0;else{this._blockhashInfo.transactionSignatures.push(o);break}}}let n=e.serialize();return await this.sendRawTransaction(n,r)}async sendRawTransaction(e,t){let r=at(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){let r={encoding:"base64"},n=t&&t.skipPreflight,s=n===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),s&&(r.preflightCommitment=s);let a=[e,r],o=ne(await this._rpcRequest("sendTransaction",a),ca);if("error"in o){let u;throw"data"in o.error&&(u=o.error.data.logs),new Kn({action:n?"send":"simulate",signature:"",transactionMessage:o.error.message,logs:u})}return o.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3)return void this._updateSubscriptions();this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){let r=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,r!==t.state){let n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach(s=>{try{s(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){let r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};let n=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return n.add(t),()=>{n.delete(t),n.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();let e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{let n=this._subscriptionsByHash[r];if(n!==void 0)switch(n.state){case"pending":case"unsubscribed":if(n.callbacks.size===0){delete this._subscriptionsByHash[r],n.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{let{args:s,method:a}=n;try{this._setSubscription(r,{...n,state:"subscribing"});let o=await this._rpcWebSocket.call(a,s);this._setSubscription(r,{...n,serverSubscriptionId:o,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[o]=n.callbacks,await this._updateSubscriptions()}catch(o){if(console.error(`Received ${o instanceof Error?"":"JSON-RPC "}error calling \`${a}\``,{args:s,error:o}),!t())return;this._setSubscription(r,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":n.callbacks.size===0&&await(async()=>{let{serverSubscriptionId:s,unsubscribeMethod:a}=n;if(this._subscriptionsAutoDisposedByRpc.has(s))this._subscriptionsAutoDisposedByRpc.delete(s);else{this._setSubscription(r,{...n,state:"unsubscribing"}),this._setSubscription(r,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(a,[s])}catch(o){if(o instanceof Error&&console.error(`${a} error:`,o.message),!t())return;this._setSubscription(r,{...n,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})()}}))}_handleServerNotification(e,t){let r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(n=>{try{n(...t)}catch(s){console.error(s)}})}_wsOnAccountNotification(e){let{result:t,subscription:r}=ne(e,No);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){let r=this._nextClientSubscriptionId++,n=Yi([e.method,t]),s=this._subscriptionsByHash[n];return s===void 0?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];let a=this._subscriptionsByHash[n];yt(a!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),a.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){let{commitment:n,config:s}=bt(r),a=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},a)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){let{result:t,subscription:r}=ne(e,Wo);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){let{commitment:s,config:a}=bt(r),o=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",a||(n?{filters:Qi(n)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){let n=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){let{result:t,subscription:r}=ne(e,la);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){let{result:t,subscription:r}=ne(e,qo);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){let{result:t,subscription:r}=ne(e,Ho);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){let r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){let s=t||this._commitment;if(s||r||n){let a={};r&&(a.encoding=r),s&&(a.commitment=s),n&&(a=Object.assign(a,n)),e.push(a)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){let s=t||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){let{result:t,subscription:r}=ne(e,Ko);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){let n=this._buildArgs([e],r||this._commitment||"finalized"),s=this._makeSubscription({callback:(a,o)=>{if(a.type==="status"){t(a.result,o);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return s}onSignatureWithOptions(e,t,r){let{commitment:n,...s}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},a=this._buildArgs([e],n,void 0,s),o=this._makeSubscription({callback:(u,b)=>{t(u,b);try{this.removeSignatureListener(o)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},a);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){let{result:t,subscription:r}=ne(e,Fo);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class tn{constructor(e){this._keypair=void 0,this._keypair=e??Di()}static generate(){return new tn(Di())}static fromSecretKey(e,t){if(e.byteLength!==64)throw Error("bad secret key size");let r=e.slice(32,64);if(!t||!t.skipValidation){let n=qn(e.slice(0,32));for(let s=0;s<32;s++)if(r[s]!==n[s])throw Error("provided secretKey is invalid")}return new tn({publicKey:r,secretKey:e})}static fromSeed(e){let t=qn(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new tn({publicKey:t,secretKey:r})}get publicKey(){return new Ue(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}let rn=Object.freeze({CreateLookupTable:{index:0,layout:f.w3([f.DH("instruction"),Hr("recentSlot"),f.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:f.w3([f.DH("instruction")])},ExtendLookupTable:{index:2,layout:f.w3([f.DH("instruction"),Hr(),f.O6(et(),f.cY(f.DH(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:f.w3([f.DH("instruction")])},CloseLookupTable:{index:4,layout:f.w3([f.DH("instruction")])}});class fa{constructor(){}static createLookupTable(e){let[t,r]=Ue.findProgramAddressSync([e.authority.toBuffer(),Si().encode(e.recentSlot)],this.programId),n=ut(rn.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Nt.programId,isSigner:!1,isWritable:!1}];return[new kt({programId:this.programId,keys:s,data:n}),t]}static freezeLookupTable(e){let t=ut(rn.FreezeLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new kt({programId:this.programId,keys:r,data:t})}static extendLookupTable(e){let t=ut(rn.ExtendLookupTable,{addresses:e.addresses.map(n=>n.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Nt.programId,isSigner:!1,isWritable:!1}),new kt({programId:this.programId,keys:r,data:t})}static deactivateLookupTable(e){let t=ut(rn.DeactivateLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new kt({programId:this.programId,keys:r,data:t})}static closeLookupTable(e){let t=ut(rn.CloseLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new kt({programId:this.programId,keys:r,data:t})}}fa.programId=new Ue("AddressLookupTab1e1111111111111111111111111");let wn=Object.freeze({RequestUnits:{index:0,layout:f.w3([f.u8("instruction"),f.DH("units"),f.DH("additionalFee")])},RequestHeapFrame:{index:1,layout:f.w3([f.u8("instruction"),f.DH("bytes")])},SetComputeUnitLimit:{index:2,layout:f.w3([f.u8("instruction"),f.DH("units")])},SetComputeUnitPrice:{index:3,layout:f.w3([f.u8("instruction"),Hr("microLamports")])}});class pa{constructor(){}static requestUnits(e){let t=ut(wn.RequestUnits,e);return new kt({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){let t=ut(wn.RequestHeapFrame,e);return new kt({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){let t=ut(wn.SetComputeUnitLimit,e);return new kt({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){let t=ut(wn.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new kt({keys:[],programId:this.programId,data:t})}}pa.programId=new Ue("ComputeBudget111111111111111111111111111111");let hs=f.w3([f.u8("numSignatures"),f.u8("padding"),f.NX("signatureOffset"),f.NX("signatureInstructionIndex"),f.NX("publicKeyOffset"),f.NX("publicKeyInstructionIndex"),f.NX("messageDataOffset"),f.NX("messageDataSize"),f.NX("messageInstructionIndex")]);class Qn{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:r,signature:n,instructionIndex:s}=e;yt(t.length===32,`Public Key must be 32 bytes but received ${t.length} bytes`),yt(n.length===64,`Signature must be 64 bytes but received ${n.length} bytes`);let a=hs.span,o=a+t.length,u=o+n.length,b=C.Buffer.alloc(u+r.length),g=s??65535;return hs.encode({numSignatures:1,padding:0,signatureOffset:o,signatureInstructionIndex:g,publicKeyOffset:a,publicKeyInstructionIndex:g,messageDataOffset:u,messageDataSize:r.length,messageInstructionIndex:g},b),b.fill(t,a),b.fill(n,o),b.fill(r,u),new kt({keys:[],programId:Qn.programId,data:b})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:r,instructionIndex:n}=e;yt(t.length===64,`Private key must be 64 bytes but received ${t.length} bytes`);try{let s=tn.fromSecretKey(t),a=s.publicKey.toBytes(),o=Ki(r,s.secretKey);return this.createInstructionWithPublicKey({publicKey:a,message:r,signature:o,instructionIndex:n})}catch(s){throw Error(`Error creating instruction; ${s}`)}}}Qn.programId=new Ue("Ed25519SigVerify111111111111111111111111111"),Un.utils.isValidPrivateKey;let ga=Un.getPublicKey,ei=f.w3([f.u8("numSignatures"),f.NX("signatureOffset"),f.u8("signatureInstructionIndex"),f.NX("ethAddressOffset"),f.u8("ethAddressInstructionIndex"),f.NX("messageDataOffset"),f.NX("messageDataSize"),f.u8("messageInstructionIndex"),f.av(20,"ethAddress"),f.av(64,"signature"),f.u8("recoveryId")]);class nn{constructor(){}static publicKeyToEthAddress(e){yt(e.length===64,`Public key must be 64 bytes but received ${e.length} bytes`);try{return C.Buffer.from(Ci(at(e))).slice(-20)}catch(t){throw Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:r,signature:n,recoveryId:s,instructionIndex:a}=e;return nn.createInstructionWithEthAddress({ethAddress:nn.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:s,instructionIndex:a})}static createInstructionWithEthAddress(e){let t,{ethAddress:r,message:n,signature:s,recoveryId:a,instructionIndex:o=0}=e;yt((t=typeof r=="string"?r.startsWith("0x")?C.Buffer.from(r.substr(2),"hex"):C.Buffer.from(r,"hex"):r).length===20,`Address must be 20 bytes but received ${t.length} bytes`);let u=12+t.length,b=u+s.length+1,g=C.Buffer.alloc(ei.span+n.length);return ei.encode({numSignatures:1,signatureOffset:u,signatureInstructionIndex:o,ethAddressOffset:12,ethAddressInstructionIndex:o,messageDataOffset:b,messageDataSize:n.length,messageInstructionIndex:o,signature:at(s),ethAddress:at(t),recoveryId:a},g),g.fill(at(n),ei.span),new kt({keys:[],programId:nn.programId,data:g})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:r,instructionIndex:n}=e;yt(t.length===32,`Private key must be 32 bytes but received ${t.length} bytes`);try{let s=at(t),a=ga(s,!1).slice(1),o=C.Buffer.from(Ci(at(r))),[u,b]=((g,m)=>{let p=Un.sign(g,m);return[p.toCompactRawBytes(),p.recovery]})(o,s);return this.createInstructionWithPublicKey({publicKey:a,message:r,signature:u,recoveryId:b,instructionIndex:n})}catch(s){throw Error(`Error creating instruction; ${s}`)}}}nn.programId=new Ue("KeccakSecp256k11111111111111111111111111111");let ma=new Ue("StakeConfig11111111111111111111111111111111");class ti{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}ti.default=new ti(0,0,Ue.default);let kr=Object.freeze({Initialize:{index:0,layout:f.w3([f.DH("instruction"),((i="authorized")=>f.w3([et("staker"),et("withdrawer")],i))(),((i="lockup")=>f.w3([f.Wg("unixTimestamp"),f.Wg("epoch"),et("custodian")],i))()])},Authorize:{index:1,layout:f.w3([f.DH("instruction"),et("newAuthorized"),f.DH("stakeAuthorizationType")])},Delegate:{index:2,layout:f.w3([f.DH("instruction")])},Split:{index:3,layout:f.w3([f.DH("instruction"),f.Wg("lamports")])},Withdraw:{index:4,layout:f.w3([f.DH("instruction"),f.Wg("lamports")])},Deactivate:{index:5,layout:f.w3([f.DH("instruction")])},Merge:{index:7,layout:f.w3([f.DH("instruction")])},AuthorizeWithSeed:{index:8,layout:f.w3([f.DH("instruction"),et("newAuthorized"),f.DH("stakeAuthorizationType"),Dr("authoritySeed"),et("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class fs{constructor(){}static initialize(e){let{stakePubkey:t,authorized:r,lockup:n}=e,s=n||ti.default,a=ut(kr.Initialize,{authorized:{staker:at(r.staker.toBuffer()),withdrawer:at(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:at(s.custodian.toBuffer())}});return new kt({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Qr,isSigner:!1,isWritable:!1}],programId:this.programId,data:a})}static createAccountWithSeed(e){let t=new ht;t.add(Nt.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static createAccount(e){let t=new ht;t.add(Nt.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,s=ut(kr.Delegate);return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:Hn,isSigner:!1,isWritable:!1},{pubkey:ma,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){let{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:s,custodianPubkey:a}=e,o=ut(kr.Authorize,{newAuthorized:at(n.toBuffer()),stakeAuthorizationType:s.index}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return a&&u.push({pubkey:a,isSigner:!0,isWritable:!1}),new ht().add({keys:u,programId:this.programId,data:o})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:s,newAuthorizedPubkey:a,stakeAuthorizationType:o,custodianPubkey:u}=e,b=ut(kr.AuthorizeWithSeed,{newAuthorized:at(a.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:at(s.toBuffer())}),g=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:hr,isSigner:!1,isWritable:!1}];return u&&g.push({pubkey:u,isSigner:!0,isWritable:!1}),new ht().add({keys:g,programId:this.programId,data:b})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:s}=e,a=ut(kr.Split,{lamports:s});return new kt({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){let r=new ht;return r.add(Nt.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,basePubkey:a,seed:o,lamports:u}=e,b=new ht;return b.add(Nt.allocate({accountPubkey:s,basePubkey:a,seed:o,space:this.space,programId:this.programId})),t&&t>0&&b.add(Nt.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:t})),b.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,lamports:u}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,s=ut(kr.Merge);return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:Hn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:s,custodianPubkey:a}=e,o=ut(kr.Withdraw,{lamports:s}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:Hn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return a&&u.push({pubkey:a,isSigner:!0,isWritable:!1}),new ht().add({keys:u,programId:this.programId,data:o})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:r}=e,n=ut(kr.Deactivate);return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}fs.programId=new Ue("Stake11111111111111111111111111111111111111"),fs.space=200;let sn=Object.freeze({InitializeAccount:{index:0,layout:f.w3([f.DH("instruction"),((i="voteInit")=>f.w3([et("nodePubkey"),et("authorizedVoter"),et("authorizedWithdrawer"),f.u8("commission")],i))()])},Authorize:{index:1,layout:f.w3([f.DH("instruction"),et("newAuthorized"),f.DH("voteAuthorizationType")])},Withdraw:{index:3,layout:f.w3([f.DH("instruction"),f.Wg("lamports")])},UpdateValidatorIdentity:{index:4,layout:f.w3([f.DH("instruction")])},AuthorizeWithSeed:{index:10,layout:f.w3([f.DH("instruction"),((i="voteAuthorizeWithSeedArgs")=>f.w3([f.DH("voteAuthorizationType"),et("currentAuthorityDerivedKeyOwnerPubkey"),Dr("currentAuthorityDerivedKeySeed"),et("newAuthorized")],i))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class kn{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:r,voteInit:n}=e,s=ut(sn.InitializeAccount,{voteInit:{nodePubkey:at(n.nodePubkey.toBuffer()),authorizedVoter:at(n.authorizedVoter.toBuffer()),authorizedWithdrawer:at(n.authorizedWithdrawer.toBuffer()),commission:n.commission}});return new kt({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static createAccount(e){let t=new ht;return t.add(Nt.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:s}=e,a=ut(sn.Authorize,{newAuthorized:at(n.toBuffer()),voteAuthorizationType:s.index});return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:s,voteAuthorizationType:a,votePubkey:o}=e,u=ut(sn.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:at(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:at(s.toBuffer()),voteAuthorizationType:a.index}});return new ht().add({keys:[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}],programId:this.programId,data:u})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:s}=e,a=ut(sn.Withdraw,{lamports:n});return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw Error("Withdraw will leave vote account with insufficient funds.");return kn.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,s=ut(sn.UpdateValidatorIdentity);return new ht().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}}kn.programId=new Ue("Vote111111111111111111111111111111111111111"),kn.space=3762,new Ue("Va1idator1nfo111111111111111111111111111111"),D({name:Q(),website:Ne(Q()),details:Ne(Q()),iconUrl:Ne(Q()),keybaseUsername:Ne(Q())}),new Ue("Vote111111111111111111111111111111111111111"),f.w3([et("nodePubkey"),et("authorizedWithdrawer"),f.u8("commission"),f.I0(),f.O6(f.w3([f.I0("slot"),f.DH("confirmationCount")]),f.cY(f.DH(),-8),"votes"),f.u8("rootSlotValid"),f.I0("rootSlot"),f.I0(),f.O6(f.w3([f.I0("epoch"),et("authorizedVoter")]),f.cY(f.DH(),-8),"authorizedVoters"),f.w3([f.O6(f.w3([et("authorizedPubkey"),f.I0("epochOfLastAuthorizedSwitch"),f.I0("targetEpoch")]),32,"buf"),f.I0("idx"),f.u8("isEmpty")],"priorVoters"),f.I0(),f.O6(f.w3([f.I0("epoch"),f.I0("credits"),f.I0("prevCredits")]),f.cY(f.DH(),-8),"epochCredits"),f.w3([f.I0("slot"),f.I0("timestamp")],"lastTimestamp")]);let ya=1e9},Wt.__chunk_4221=(At,je,de)=>{var Oe=de(5356),xe=Oe.Buffer;function C(q,U){for(var F in q)U[F]=q[F]}function $(q,U,F){return xe(q,U,F)}xe.from&&xe.alloc&&xe.allocUnsafe&&xe.allocUnsafeSlow?At.exports=Oe:(C(Oe,je),je.Buffer=$),$.prototype=Object.create(xe.prototype),C(xe,$),$.from=function(q,U,F){if(typeof q=="number")throw TypeError("Argument must not be a number");return xe(q,U,F)},$.alloc=function(q,U,F){if(typeof q!="number")throw TypeError("Argument must be a number");var K=xe(q);return U!==void 0?typeof F=="string"?K.fill(U,F):K.fill(U):K.fill(0),K},$.allocUnsafe=function(q){if(typeof q!="number")throw TypeError("Argument must be a number");return xe(q)},$.allocUnsafeSlow=function(q){if(typeof q!="number")throw TypeError("Argument must be a number");return Oe.SlowBuffer(q)}},Wt.__chunk_3550=(At,je,de)=>{At.exports=de(7989)("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},Wt.__chunk_3537=(At,je,de)=>{"use strict";je.I0=je.DH=je.NX=je.u8=je.cY=void 0,je.av=je.O6=je.w3=je.Wg=void 0;let Oe=de(5356);function xe(re){if(!(re instanceof Uint8Array))throw TypeError("b must be a Uint8Array")}function C(re){return xe(re),Oe.Buffer.from(re.buffer,re.byteOffset,re.length)}class ${constructor(w,v){if(!Number.isInteger(w))throw TypeError("span must be an integer");this.span=w,this.property=v}makeDestinationObject(){return{}}getSpan(w,v){if(0>this.span)throw RangeError("indeterminate span");return this.span}replicate(w){let v=Object.create(this.constructor.prototype);return Object.assign(v,this),v.property=w,v}fromArray(w){}}function q(re,w){return w.property?re+"["+w.property+"]":re}class U extends ${isCount(){throw Error("ExternalLayout is abstract")}}class F extends U{constructor(w,v=0,z){if(!(w instanceof $))throw TypeError("layout must be a Layout");if(!Number.isInteger(v))throw TypeError("offset must be integer or undefined");super(w.span,z||w.property),this.layout=w,this.offset=v}isCount(){return this.layout instanceof K||this.layout instanceof R}decode(w,v=0){return this.layout.decode(w,v+this.offset)}encode(w,v,z=0){return this.layout.encode(w,v,z+this.offset)}}class K extends ${constructor(w,v){if(super(w,v),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(w,v=0){return C(w).readUIntLE(v,this.span)}encode(w,v,z=0){return C(v).writeUIntLE(w,z,this.span),this.span}}class R extends ${constructor(w,v){if(super(w,v),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(w,v=0){return C(w).readUIntBE(v,this.span)}encode(w,v,z=0){return C(v).writeUIntBE(w,z,this.span),this.span}}function ee(re){let w=Math.floor(re/4294967296);return{hi32:w,lo32:re-4294967296*w}}function M(re,w){return 4294967296*re+w}class le extends ${constructor(w){super(8,w)}decode(w,v=0){let z=C(w),ge=z.readUInt32LE(v);return M(z.readUInt32LE(v+4),ge)}encode(w,v,z=0){let ge=ee(w),We=C(v);return We.writeUInt32LE(ge.lo32,z),We.writeUInt32LE(ge.hi32,z+4),8}}class L extends ${constructor(w){super(8,w)}decode(w,v=0){let z=C(w),ge=z.readUInt32LE(v);return M(z.readInt32LE(v+4),ge)}encode(w,v,z=0){let ge=ee(w),We=C(v);return We.writeUInt32LE(ge.lo32,z),We.writeInt32LE(ge.hi32,z+4),8}}class j extends ${constructor(w,v,z){if(!(w instanceof $))throw TypeError("elementLayout must be a Layout");if(!(v instanceof U&&v.isCount()||Number.isInteger(v)&&0<=v))throw TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let ge=-1;v instanceof U||!(0<w.span)||(ge=v*w.span),super(ge,z),this.elementLayout=w,this.count=v}getSpan(w,v=0){if(0<=this.span)return this.span;let z=0,ge=this.count;if(ge instanceof U&&(ge=ge.decode(w,v)),0<this.elementLayout.span)z=ge*this.elementLayout.span;else{let We=0;for(;We<ge;)z+=this.elementLayout.getSpan(w,v+z),++We}return z}decode(w,v=0){let z=[],ge=0,We=this.count;for(We instanceof U&&(We=We.decode(w,v));ge<We;)z.push(this.elementLayout.decode(w,v)),v+=this.elementLayout.getSpan(w,v),ge+=1;return z}encode(w,v,z=0){let ge=this.elementLayout,We=w.reduce((xt,ie)=>xt+ge.encode(ie,v,z+xt),0);return this.count instanceof U&&this.count.encode(w.length,v,z),We}}class Y extends ${constructor(w,v,z){if(!(Array.isArray(w)&&w.reduce((We,xt)=>We&&xt instanceof $,!0)))throw TypeError("fields must be array of Layout instances");for(let We of(typeof v=="boolean"&&z===void 0&&(z=v,v=void 0),w))if(0>We.span&&We.property===void 0)throw Error("fields cannot contain unnamed variable-length layout");let ge=-1;try{ge=w.reduce((We,xt)=>We+xt.getSpan(),0)}catch{}super(ge,v),this.fields=w,this.decodePrefixes=!!z}getSpan(w,v=0){if(0<=this.span)return this.span;let z=0;try{z=this.fields.reduce((ge,We)=>{let xt=We.getSpan(w,v);return v+=xt,ge+xt},0)}catch{throw RangeError("indeterminate span")}return z}decode(w,v=0){xe(w);let z=this.makeDestinationObject();for(let ge of this.fields)if(ge.property!==void 0&&(z[ge.property]=ge.decode(w,v)),v+=ge.getSpan(w,v),this.decodePrefixes&&w.length===v)break;return z}encode(w,v,z=0){let ge=z,We=0,xt=0;for(let ie of this.fields){let ae=ie.span;if(xt=0<ae?ae:0,ie.property!==void 0){let Fe=w[ie.property];Fe!==void 0&&(xt=ie.encode(Fe,v,z),0>ae&&(ae=ie.getSpan(v,z)))}We=z,z+=ae}return We+xt-ge}fromArray(w){let v=this.makeDestinationObject();for(let z of this.fields)z.property!==void 0&&0<w.length&&(v[z.property]=w.shift());return v}layoutFor(w){if(typeof w!="string")throw TypeError("property must be string");for(let v of this.fields)if(v.property===w)return v}offsetOf(w){if(typeof w!="string")throw TypeError("property must be string");let v=0;for(let z of this.fields){if(z.property===w)return v;0>z.span?v=-1:0<=v&&(v+=z.span)}}}function Ee(re){return 0>re&&(re+=4294967296),re}class H extends ${constructor(w,v,z){if(!(w instanceof K||w instanceof R))throw TypeError("word must be a UInt or UIntBE layout");if(typeof v=="string"&&z===void 0&&(z=v,v=!1),4<w.span)throw RangeError("word cannot exceed 32 bits");super(w.span,z),this.word=w,this.msb=!!v,this.fields=[];let ge=0;this._packedSetValue=function(We){return ge=Ee(We),this},this._packedGetValue=function(){return ge}}decode(w,v=0){let z=this.makeDestinationObject(),ge=this.word.decode(w,v);for(let We of(this._packedSetValue(ge),this.fields))We.property!==void 0&&(z[We.property]=We.decode(w));return z}encode(w,v,z=0){let ge=this.word.decode(v,z);for(let We of(this._packedSetValue(ge),this.fields))if(We.property!==void 0){let xt=w[We.property];xt!==void 0&&We.encode(xt)}return this.word.encode(this._packedGetValue(),v,z)}addField(w,v){let z=new Ce(this,w,v);return this.fields.push(z),z}addBoolean(w){let v=new Ge(this,w);return this.fields.push(v),v}fieldFor(w){if(typeof w!="string")throw TypeError("property must be string");for(let v of this.fields)if(v.property===w)return v}}class Ce{constructor(w,v,z){if(!(w instanceof H))throw TypeError("container must be a BitStructure");if(!Number.isInteger(v)||0>=v)throw TypeError("bits must be positive integer");let ge=8*w.span,We=w.fields.reduce((xt,ie)=>xt+ie.bits,0);if(v+We>ge)throw Error("bits too long for span remainder ("+(ge-We)+" of "+ge+" remain)");this.container=w,this.bits=v,this.valueMask=(1<<v)-1,v===32&&(this.valueMask=4294967295),this.start=We,this.container.msb&&(this.start=ge-We-v),this.wordMask=Ee(this.valueMask<<this.start),this.property=z}decode(w,v){return Ee(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(w){if(typeof w!="number"||!Number.isInteger(w)||w!==Ee(w&this.valueMask))throw TypeError(q("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let v=this.container._packedGetValue(),z=Ee(w<<this.start);this.container._packedSetValue(Ee(v&~this.wordMask)|z)}}class Ge extends Ce{constructor(w,v){super(w,1,v)}decode(w,v){return!!super.decode(w,v)}encode(w){typeof w=="boolean"&&(w*=1),super.encode(w)}}class Le extends ${constructor(w,v){if(!(w instanceof U&&w.isCount()||Number.isInteger(w)&&0<=w))throw TypeError("length must be positive integer or an unsigned integer ExternalLayout");let z=-1;w instanceof U||(z=w),super(z,v),this.length=w}getSpan(w,v){let z=this.span;return 0>z&&(z=this.length.decode(w,v)),z}decode(w,v=0){let z=this.span;return 0>z&&(z=this.length.decode(w,v)),C(w).slice(v,v+z)}encode(w,v,z){let ge=this.length;if(this.length instanceof U&&(ge=w.length),!(w instanceof Uint8Array&&ge===w.length))throw TypeError(q("Blob.encode",this)+" requires (length "+ge+") Uint8Array as src");if(z+ge>v.length)throw RangeError("encoding overruns Uint8Array");let We=C(w);return C(v).write(We.toString("hex"),z,ge,"hex"),this.length instanceof U&&this.length.encode(ge,v,z),ge}}je.cY=(re,w,v)=>new F(re,w,v),je.u8=re=>new K(1,re),je.NX=re=>new K(2,re),je.DH=re=>new K(4,re),je.I0=re=>new le(re),je.Wg=re=>new L(re),je.w3=(re,w,v)=>new Y(re,w,v),je.O6=(re,w,v)=>new j(re,w,v),je.av=(re,w)=>new Le(re,w)},Wt.__chunk_2975=At=>{"use strict";var je=Object.prototype.hasOwnProperty,de="~";function Oe(){}function xe(U,F,K){this.fn=U,this.context=F,this.once=K||!1}function C(U,F,K,R,ee){if(typeof K!="function")throw TypeError("The listener must be a function");var M=new xe(K,R||U,ee),le=de?de+F:F;return U._events[le]?U._events[le].fn?U._events[le]=[U._events[le],M]:U._events[le].push(M):(U._events[le]=M,U._eventsCount++),U}function $(U,F){--U._eventsCount==0?U._events=new Oe:delete U._events[F]}function q(){this._events=new Oe,this._eventsCount=0}Object.create&&(Oe.prototype=Object.create(null),new Oe().__proto__||(de=!1)),q.prototype.eventNames=function(){var U,F,K=[];if(this._eventsCount===0)return K;for(F in U=this._events)je.call(U,F)&&K.push(de?F.slice(1):F);return Object.getOwnPropertySymbols?K.concat(Object.getOwnPropertySymbols(U)):K},q.prototype.listeners=function(U){var F=de?de+U:U,K=this._events[F];if(!K)return[];if(K.fn)return[K.fn];for(var R=0,ee=K.length,M=Array(ee);R<ee;R++)M[R]=K[R].fn;return M},q.prototype.listenerCount=function(U){var F=de?de+U:U,K=this._events[F];return K?K.fn?1:K.length:0},q.prototype.emit=function(U,F,K,R,ee,M){var le=de?de+U:U;if(!this._events[le])return!1;var L,j,Y=this._events[le],Ee=arguments.length;if(Y.fn){switch(Y.once&&this.removeListener(U,Y.fn,void 0,!0),Ee){case 1:return Y.fn.call(Y.context),!0;case 2:return Y.fn.call(Y.context,F),!0;case 3:return Y.fn.call(Y.context,F,K),!0;case 4:return Y.fn.call(Y.context,F,K,R),!0;case 5:return Y.fn.call(Y.context,F,K,R,ee),!0;case 6:return Y.fn.call(Y.context,F,K,R,ee,M),!0}for(j=1,L=Array(Ee-1);j<Ee;j++)L[j-1]=arguments[j];Y.fn.apply(Y.context,L)}else{var H,Ce=Y.length;for(j=0;j<Ce;j++)switch(Y[j].once&&this.removeListener(U,Y[j].fn,void 0,!0),Ee){case 1:Y[j].fn.call(Y[j].context);break;case 2:Y[j].fn.call(Y[j].context,F);break;case 3:Y[j].fn.call(Y[j].context,F,K);break;case 4:Y[j].fn.call(Y[j].context,F,K,R);break;default:if(!L)for(H=1,L=Array(Ee-1);H<Ee;H++)L[H-1]=arguments[H];Y[j].fn.apply(Y[j].context,L)}}return!0},q.prototype.on=function(U,F,K){return C(this,U,F,K,!1)},q.prototype.once=function(U,F,K){return C(this,U,F,K,!0)},q.prototype.removeListener=function(U,F,K,R){var ee=de?de+U:U;if(!this._events[ee])return this;if(!F)return $(this,ee),this;var M=this._events[ee];if(M.fn)M.fn!==F||R&&!M.once||K&&M.context!==K||$(this,ee);else{for(var le=0,L=[],j=M.length;le<j;le++)(M[le].fn!==F||R&&!M[le].once||K&&M[le].context!==K)&&L.push(M[le]);L.length?this._events[ee]=L.length===1?L[0]:L:$(this,ee)}return this},q.prototype.removeAllListeners=function(U){var F;return U?(F=de?de+U:U,this._events[F]&&$(this,F)):(this._events=new Oe,this._eventsCount=0),this},q.prototype.off=q.prototype.removeListener,q.prototype.addListener=q.prototype.on,q.prefixed=de,q.EventEmitter=q,At.exports=q},Wt.__chunk_2972=(At,je,de)=>{"use strict";de.d(je,{v4:()=>F});var Oe,xe=new Uint8Array(16);let C=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;for(var $=[],q=0;q<256;++q)$.push((q+256).toString(16).substr(1));let U=function(K){var R=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,ee=($[K[R+0]]+$[K[R+1]]+$[K[R+2]]+$[K[R+3]]+"-"+$[K[R+4]]+$[K[R+5]]+"-"+$[K[R+6]]+$[K[R+7]]+"-"+$[K[R+8]]+$[K[R+9]]+"-"+$[K[R+10]]+$[K[R+11]]+$[K[R+12]]+$[K[R+13]]+$[K[R+14]]+$[K[R+15]]).toLowerCase();if(!(typeof ee=="string"&&C.test(ee)))throw TypeError("Stringified UUID is invalid");return ee},F=function(K,R,ee){var M=(K=K||{}).random||(K.rng||function(){if(!Oe&&!(Oe=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto)))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Oe(xe)})();if(M[6]=15&M[6]|64,M[8]=63&M[8]|128,R){ee=ee||0;for(var le=0;le<16;++le)R[ee+le]=M[le];return R}return U(M)}},Wt.__chunk_1969=(At,je)=>{"use strict";function de(R,ee,M){return ee<=R&&R<=M}function Oe(R){if(R===void 0)return{};if(R===Object(R))return R;throw TypeError("Could not convert argument to dictionary")}function xe(R){this.tokens=[].slice.call(R)}function C(R,ee){if(R)throw TypeError("Decoder error");return ee||65533}xe.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():-1},prepend:function(R){if(Array.isArray(R))for(;R.length;)this.tokens.unshift(R.pop());else this.tokens.unshift(R)},push:function(R){if(Array.isArray(R))for(;R.length;)this.tokens.push(R.shift());else this.tokens.push(R)}};var $="utf-8";function q(R,ee){if(!(this instanceof q))return new q(R,ee);if((R=R!==void 0?String(R).toLowerCase():$)!==$)throw Error("Encoding not supported. Only utf-8 is supported");ee=Oe(ee),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!ee.fatal,this._ignoreBOM=!!ee.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}function U(R,ee){if(!(this instanceof U))return new U(R,ee);if((R=R!==void 0?String(R).toLowerCase():$)!==$)throw Error("Encoding not supported. Only utf-8 is supported");ee=Oe(ee),this._streaming=!1,this._encoder=null,this._options={fatal:!!ee.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}function F(R){var ee=R.fatal,M=0,le=0,L=0,j=128,Y=191;this.handler=function(Ee,H){if(H===-1&&L!==0)return L=0,C(ee);if(H===-1)return-1;if(L===0){if(de(H,0,127))return H;if(de(H,194,223))L=1,M=H-192;else if(de(H,224,239))H===224&&(j=160),H===237&&(Y=159),L=2,M=H-224;else{if(!de(H,240,244))return C(ee);H===240&&(j=144),H===244&&(Y=143),L=3,M=H-240}return M<<=6*L,null}if(!de(H,j,Y))return M=L=le=0,j=128,Y=191,Ee.prepend(H),C(ee);if(j=128,Y=191,le+=1,M+=H-128<<6*(L-le),le!==L)return null;var Ce=M;return M=L=le=0,Ce}}function K(R){R.fatal,this.handler=function(ee,M){if(M===-1)return-1;if(de(M,0,127))return M;de(M,128,2047)?(le=1,L=192):de(M,2048,65535)?(le=2,L=224):de(M,65536,1114111)&&(le=3,L=240);for(var le,L,j=[(M>>6*le)+L];le>0;){var Y=M>>6*(le-1);j.push(128|63&Y),le-=1}return j}}q.prototype={decode:function(R,ee){M=typeof R=="object"&&R instanceof ArrayBuffer?new Uint8Array(R):typeof R=="object"&&"buffer"in R&&R.buffer instanceof ArrayBuffer?new Uint8Array(R.buffer,R.byteOffset,R.byteLength):new Uint8Array(0),ee=Oe(ee),this._streaming||(this._decoder=new F({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!ee.stream;for(var M,le,L=new xe(M),j=[];!L.endOfStream()&&(le=this._decoder.handler(L,L.read()))!==-1;)le!==null&&(Array.isArray(le)?j.push.apply(j,le):j.push(le));if(!this._streaming){do{if((le=this._decoder.handler(L,L.read()))===-1)break;le!==null&&(Array.isArray(le)?j.push.apply(j,le):j.push(le))}while(!L.endOfStream());this._decoder=null}!j.length||["utf-8"].indexOf(this.encoding)===-1||this._ignoreBOM||this._BOMseen||(j[0]===65279?(this._BOMseen=!0,j.shift()):this._BOMseen=!0);for(var Y="",Ee=0;Ee<j.length;++Ee){var H=j[Ee];H<=65535?Y+=String.fromCharCode(H):(H-=65536,Y+=String.fromCharCode((H>>10)+55296,(1023&H)+56320))}return Y}},U.prototype={encode:function(R,ee){R=R?String(R):"",ee=Oe(ee),this._streaming||(this._encoder=new K(this._options)),this._streaming=!!ee.stream;for(var M,le=[],L=new xe(function(j){for(var Y=String(j),Ee=Y.length,H=0,Ce=[];H<Ee;){var Ge=Y.charCodeAt(H);if(Ge<55296||Ge>57343)Ce.push(Ge);else if(56320<=Ge&&Ge<=57343)Ce.push(65533);else if(55296<=Ge&&Ge<=56319)if(H===Ee-1)Ce.push(65533);else{var Le=j.charCodeAt(H+1);if(56320<=Le&&Le<=57343){var re=1023&Ge,w=1023&Le;Ce.push(65536+(re<<10)+w),H+=1}else Ce.push(65533)}H+=1}return Ce}(R));!L.endOfStream()&&(M=this._encoder.handler(L,L.read()))!==-1;)Array.isArray(M)?le.push.apply(le,M):le.push(M);if(!this._streaming){for(;(M=this._encoder.handler(L,L.read()))!==-1;)Array.isArray(M)?le.push.apply(le,M):le.push(M);this._encoder=null}return new Uint8Array(le)}},je.TextEncoder=U,je.TextDecoder=q},Wt.__chunk_82=(At,je,de)=>{"use strict";var Oe=de(4221).Buffer;At.exports=function(xe){if(xe.length>=255)throw TypeError("Alphabet too long");for(var C=new Uint8Array(256),$=0;$<C.length;$++)C[$]=255;for(var q=0;q<xe.length;q++){var U=xe.charAt(q),F=U.charCodeAt(0);if(C[F]!==255)throw TypeError(U+" is ambiguous");C[F]=q}var K=xe.length,R=xe.charAt(0),ee=Math.log(K)/Math.log(256),M=Math.log(256)/Math.log(K);function le(L){if(typeof L!="string")throw TypeError("Expected String");if(L.length===0)return Oe.alloc(0);for(var j=0,Y=0,Ee=0;L[j]===R;)Y++,j++;for(var H=(L.length-j)*ee+1>>>0,Ce=new Uint8Array(H);j<L.length;){var Ge=L.charCodeAt(j);if(Ge>255)return;var Le=C[Ge];if(Le===255)return;for(var re=0,w=H-1;(Le!==0||re<Ee)&&w!==-1;w--,re++)Le+=K*Ce[w]>>>0,Ce[w]=Le%256>>>0,Le=Le/256>>>0;if(Le!==0)throw Error("Non-zero carry");Ee=re,j++}for(var v=H-Ee;v!==H&&Ce[v]===0;)v++;var z=Oe.allocUnsafe(Y+(H-v));z.fill(0,0,Y);for(var ge=Y;v!==H;)z[ge++]=Ce[v++];return z}return{encode:function(L){if((Array.isArray(L)||L instanceof Uint8Array)&&(L=Oe.from(L)),!Oe.isBuffer(L))throw TypeError("Expected Buffer");if(L.length===0)return"";for(var j=0,Y=0,Ee=0,H=L.length;Ee!==H&&L[Ee]===0;)Ee++,j++;for(var Ce=(H-Ee)*M+1>>>0,Ge=new Uint8Array(Ce);Ee!==H;){for(var Le=L[Ee],re=0,w=Ce-1;(Le!==0||re<Y)&&w!==-1;w--,re++)Le+=256*Ge[w]>>>0,Ge[w]=Le%K>>>0,Le=Le/K>>>0;if(Le!==0)throw Error("Non-zero carry");Y=re,Ee++}for(var v=Ce-Y;v!==Ce&&Ge[v]===0;)v++;for(var z=R.repeat(j);v<Ce;++v)z+=xe.charAt(Ge[v]);return z},decodeUnsafe:le,decode:function(L){var j=le(L);if(j)return j;throw Error("Non-base"+K+" character")}}}},Wt);export{ka as __getNamedExports};
